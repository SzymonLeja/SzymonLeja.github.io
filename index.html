<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<script>

var e, t;
e = this, t = function() {
    "use strict";

    function e(t) {
        return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(t)
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    function n(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function r(e, t, r) {
        return t && n(e.prototype, t), r && n(e, r), e
    }

    function i(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }

    function o(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }))), n.push.apply(n, r)
        }
        return n
    }

    function c(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? o(Object(n), !0).forEach((function(t) {
                i(e, t, n[t])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o(Object(n)).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }))
        }
        return e
    }

    function s(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }), t && u(e, t)
    }

    function a(e) {
        return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function u(e, t) {
        return (u = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }

    function h() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
        } catch (e) {
            return !1
        }
    }

    function f(e, t) {
        return !t || "object" != typeof t && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function l(e) {
        return function() {
            var t, n = a(e);
            if (h()) {
                var r = a(this).constructor;
                t = Reflect.construct(n, arguments, r)
            } else t = n.apply(this, arguments);
            return f(this, t)
        }
    }

    function d(e) {
        return function(e) {
            if (Array.isArray(e)) return v(e)
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e)
        }(e) || function(e, t) {
            if (e) {
                if ("string" == typeof e) return v(e, t);
                var n = Object.prototype.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(n) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? v(e, t) : void 0
            }
        }(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function v(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
        return r
    }

    function y(e) {
        return Array.isArray ? Array.isArray(e) : "[object Array]" === Object.prototype.toString.call(e)
    }

    function g(e) {
        return "string" == typeof e
    }

    function p(e) {
        return "number" == typeof e
    }

    function m(e) {
        return null != e
    }

    function k(e) {
        return !e.trim().length
    }
    var M = function(e) {
            return "Invalid value for key ".concat(e)
        },
        b = function(e) {
            return "Pattern length exceeds max of ".concat(e, ".")
        },
        x = Object.prototype.hasOwnProperty,
        S = function() {
            function e(n) {
                var r = this;
                t(this, e), this._keys = {}, this._keyNames = [];
                var i = 0;
                n.forEach((function(e) {
                    var t, n = 1;
                    if (g(e)) t = e;
                    else {
                        if (!x.call(e, "name")) throw new Error("Missing ".concat("name", " property in key"));
                        if (t = e.name, x.call(e, "weight") && (n = e.weight) <= 0) throw new Error(function(e) {
                            return "Property 'weight' in key '".concat(e, "' must be a positive integer")
                        }(t))
                    }
                    r._keyNames.push(t), r._keys[t] = {
                        weight: n
                    }, i += n
                })), this._keyNames.forEach((function(e) {
                    r._keys[e].weight /= i
                }))
            }
            return r(e, [{
                key: "get",
                value: function(e, t) {
                    return this._keys[e] && this._keys[e][t]
                }
            }, {
                key: "keys",
                value: function() {
                    return this._keyNames
                }
            }, {
                key: "toJSON",
                value: function() {
                    return JSON.stringify(this._keys)
                }
            }]), e
        }(),
        _ = c({}, {
            isCaseSensitive: !1,
            includeScore: !1,
            keys: [],
            shouldSort: !0,
            sortFn: function(e, t) {
                return e.score === t.score ? e.idx < t.idx ? -1 : 1 : e.score < t.score ? -1 : 1
            }
        }, {}, {
            includeMatches: !1,
            findAllMatches: !1,
            minMatchCharLength: 1
        }, {}, {
            location: 0,
            threshold: .6,
            distance: 100
        }, {}, {
            useExtendedSearch: !1,
            getFn: function(e, t) {
                var n = [],
                    r = !1;
                return function e(t, i) {
                    if (i) {
                        var o = i.indexOf("."),
                            c = i,
                            s = null; - 1 !== o && (c = i.slice(0, o), s = i.slice(o + 1));
                        var a = t[c];
                        if (!m(a)) return;
                        if (s || !g(a) && !p(a))
                            if (y(a)) {
                                r = !0;
                                for (var u = 0, h = a.length; u < h; u += 1) e(a[u], s)
                            } else s && e(a, s);
                        else n.push(function(e) {
                            return null == e ? "" : function(e) {
                                if ("string" == typeof e) return e;
                                var t = e + "";
                                return "0" == t && 1 / e == -1 / 0 ? "-0" : t
                            }(e)
                        }(a))
                    } else n.push(t)
                }(e, t), r ? n : n[0]
            }
        }),
        w = /[^ ]+/g;

    function O() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3,
            t = new Map;
        return {
            get: function(n) {
                var r = n.match(w).length;
                if (t.has(r)) return t.get(r);
                var i = parseFloat((1 / Math.sqrt(r)).toFixed(e));
                return t.set(r, i), i
            },
            clear: function() {
                t.clear()
            }
        }
    }
    var C = function() {
        function e() {
            var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                r = n.getFn,
                i = void 0 === r ? _.getFn : r;
            t(this, e), this.norm = O(3), this.getFn = i, this.isCreated = !1, this.setRecords()
        }
        return r(e, [{
            key: "setCollection",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                this.docs = e
            }
        }, {
            key: "setRecords",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                this.records = e
            }
        }, {
            key: "setKeys",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                this.keys = e
            }
        }, {
            key: "create",
            value: function() {
                var e = this;
                !this.isCreated && this.docs.length && (this.isCreated = !0, g(this.docs[0]) ? this.docs.forEach((function(t, n) {
                    e._addString(t, n)
                })) : this.docs.forEach((function(t, n) {
                    e._addObject(t, n)
                })), this.norm.clear())
            }
        }, {
            key: "add",
            value: function(e) {
                var t = this.size();
                g(e) ? this._addString(e, t) : this._addObject(e, t)
            }
        }, {
            key: "removeAt",
            value: function(e) {
                this.records.splice(e, 1);
                for (var t = e, n = this.size(); t < n; t += 1) this.records[t].i -= 1
            }
        }, {
            key: "size",
            value: function() {
                return this.records.length
            }
        }, {
            key: "_addString",
            value: function(e, t) {
                if (m(e) && !k(e)) {
                    var n = {
                        v: e,
                        i: t,
                        n: this.norm.get(e)
                    };
                    this.records.push(n)
                }
            }
        }, {
            key: "_addObject",
            value: function(e, t) {
                var n = this,
                    r = {
                        i: t,
                        $: {}
                    };
                this.keys.forEach((function(t, i) {
                    var o = n.getFn(e, t);
                    if (m(o))
                        if (y(o)) ! function() {
                            for (var e = [], t = [{
                                    nestedArrIndex: -1,
                                    value: o
                                }]; t.length;) {
                                var c = t.pop(),
                                    s = c.nestedArrIndex,
                                    a = c.value;
                                if (m(a))
                                    if (g(a) && !k(a)) {
                                        var u = {
                                            v: a,
                                            i: s,
                                            n: n.norm.get(a)
                                        };
                                        e.push(u)
                                    } else y(a) && a.forEach((function(e, n) {
                                        t.push({
                                            nestedArrIndex: n,
                                            value: e
                                        })
                                    }))
                            }
                            r.$[i] = e
                        }();
                        else if (!k(o)) {
                        var c = {
                            v: o,
                            n: n.norm.get(o)
                        };
                        r.$[i] = c
                    }
                })), this.records.push(r)
            }
        }, {
            key: "toJSON",
            value: function() {
                return {
                    keys: this.keys,
                    records: this.records
                }
            }
        }]), e
    }();

    function L(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = n.getFn,
            i = void 0 === r ? _.getFn : r,
            o = new C({
                getFn: i
            });
        return o.setKeys(e), o.setCollection(t), o.create(), o
    }

    function j(e, t) {
        var n = e.matches;
        t.matches = [], m(n) && n.forEach((function(e) {
            if (m(e.indices) && e.indices.length) {
                var n = {
                    indices: e.indices,
                    value: e.value
                };
                e.key && (n.key = e.key), e.idx > -1 && (n.refIndex = e.idx), t.matches.push(n)
            }
        }))
    }

    function A(e, t) {
        t.score = e.score
    }

    function E(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = t.errors,
            r = void 0 === n ? 0 : n,
            i = t.currentLocation,
            o = void 0 === i ? 0 : i,
            c = t.expectedLocation,
            s = void 0 === c ? 0 : c,
            a = t.distance,
            u = void 0 === a ? _.distance : a,
            h = r / e.length,
            f = Math.abs(s - o);
        return u ? h + f / u : f ? 1 : h
    }

    function I() {
        for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _.minMatchCharLength, n = [], r = -1, i = -1, o = 0, c = e.length; o < c; o += 1) {
            var s = e[o];
            s && -1 === r ? r = o : s || -1 === r || ((i = o - 1) - r + 1 >= t && n.push([r, i]), r = -1)
        }
        return e[o - 1] && o - r >= t && n.push([r, o - 1]), n
    }

    function $(e) {
        for (var t = {}, n = 0, r = e.length; n < r; n += 1) {
            var i = e.charAt(n);
            t[i] = (t[i] || 0) | 1 << r - n - 1
        }
        return t
    }
    var R = function() {
            function e(n) {
                var r = this,
                    i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    o = i.location,
                    c = void 0 === o ? _.location : o,
                    s = i.threshold,
                    a = void 0 === s ? _.threshold : s,
                    u = i.distance,
                    h = void 0 === u ? _.distance : u,
                    f = i.includeMatches,
                    l = void 0 === f ? _.includeMatches : f,
                    d = i.findAllMatches,
                    v = void 0 === d ? _.findAllMatches : d,
                    y = i.minMatchCharLength,
                    g = void 0 === y ? _.minMatchCharLength : y,
                    p = i.isCaseSensitive,
                    m = void 0 === p ? _.isCaseSensitive : p;
                if (t(this, e), this.options = {
                        location: c,
                        threshold: a,
                        distance: h,
                        includeMatches: l,
                        findAllMatches: v,
                        minMatchCharLength: g,
                        isCaseSensitive: m
                    }, this.pattern = m ? n : n.toLowerCase(), this.chunks = [], this.pattern.length) {
                    var k = function(e, t) {
                            r.chunks.push({
                                pattern: e,
                                alphabet: $(e),
                                startIndex: t
                            })
                        },
                        M = this.pattern.length;
                    if (M > 32) {
                        for (var b = 0, x = M % 32, S = M - x; b < S;) k(this.pattern.substr(b, 32), b), b += 32;
                        if (x) {
                            var w = M - 32;
                            k(this.pattern.substr(w), w)
                        }
                    } else k(this.pattern, 0)
                }
            }
            return r(e, [{
                key: "searchIn",
                value: function(e) {
                    var t = this.options,
                        n = t.isCaseSensitive,
                        r = t.includeMatches;
                    if (n || (e = e.toLowerCase()), this.pattern === e) {
                        var i = {
                            isMatch: !0,
                            score: 0
                        };
                        return r && (i.indices = [
                            [0, e.length - 1]
                        ]), i
                    }
                    var o = this.options,
                        c = o.location,
                        s = o.distance,
                        a = o.threshold,
                        u = o.findAllMatches,
                        h = o.minMatchCharLength,
                        f = [],
                        l = 0,
                        v = !1;
                    this.chunks.forEach((function(t) {
                        var n = t.pattern,
                            i = t.alphabet,
                            o = t.startIndex,
                            y = function(e, t, n) {
                                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                                    i = r.location,
                                    o = void 0 === i ? _.location : i,
                                    c = r.distance,
                                    s = void 0 === c ? _.distance : c,
                                    a = r.threshold,
                                    u = void 0 === a ? _.threshold : a,
                                    h = r.findAllMatches,
                                    f = void 0 === h ? _.findAllMatches : h,
                                    l = r.minMatchCharLength,
                                    d = void 0 === l ? _.minMatchCharLength : l,
                                    v = r.includeMatches,
                                    y = void 0 === v ? _.includeMatches : v;
                                if (t.length > 32) throw new Error(b(32));
                                var g, p = t.length,
                                    m = e.length,
                                    k = Math.max(0, Math.min(o, m)),
                                    M = u,
                                    x = k,
                                    S = [];
                                if (y)
                                    for (var w = 0; w < m; w += 1) S[w] = 0;
                                for (;
                                    (g = e.indexOf(t, x)) > -1;) {
                                    var O = E(t, {
                                        currentLocation: g,
                                        expectedLocation: k,
                                        distance: s
                                    });
                                    if (M = Math.min(O, M), x = g + p, y)
                                        for (var C = 0; C < p;) S[g + C] = 1, C += 1
                                }
                                x = -1;
                                for (var L = [], j = 1, A = p + m, $ = 1 << p - 1, R = 0; R < p; R += 1) {
                                    for (var P = 0, F = A; P < F;) {
                                        var N = E(t, {
                                            errors: R,
                                            currentLocation: k + F,
                                            expectedLocation: k,
                                            distance: s
                                        });
                                        N <= M ? P = F : A = F, F = Math.floor((A - P) / 2 + P)
                                    }
                                    A = F;
                                    var D = Math.max(1, k - F + 1),
                                        z = f ? m : Math.min(k + F, m) + p,
                                        q = Array(z + 2);
                                    q[z + 1] = (1 << R) - 1;
                                    for (var W = z; W >= D; W -= 1) {
                                        var J = W - 1,
                                            K = n[e.charAt(J)];
                                        if (K && y && (S[J] = 1), q[W] = (q[W + 1] << 1 | 1) & K, 0 !== R && (q[W] |= (L[W + 1] | L[W]) << 1 | 1 | L[W + 1]), q[W] & $ && (j = E(t, {
                                                errors: R,
                                                currentLocation: J,
                                                expectedLocation: k,
                                                distance: s
                                            })) <= M) {
                                            if (M = j, (x = J) <= k) break;
                                            D = Math.max(1, 2 * k - x)
                                        }
                                    }
                                    var T = E(t, {
                                        errors: R + 1,
                                        currentLocation: k,
                                        expectedLocation: k,
                                        distance: s
                                    });
                                    if (T > M) break;
                                    L = q
                                }
                                var U = {
                                    isMatch: x >= 0,
                                    score: Math.max(.001, j)
                                };
                                return y && (U.indices = I(S, d)), U
                            }(e, n, i, {
                                location: c + o,
                                distance: s,
                                threshold: a,
                                findAllMatches: u,
                                minMatchCharLength: h,
                                includeMatches: r
                            }),
                            g = y.isMatch,
                            p = y.score,
                            m = y.indices;
                        g && (v = !0), l += p, g && m && (f = [].concat(d(f), d(m)))
                    }));
                    var y = {
                        isMatch: v,
                        score: v ? l / this.chunks.length : 1
                    };
                    return v && r && (y.indices = f), y
                }
            }]), e
        }(),
        P = function() {
            function e(n) {
                t(this, e), this.pattern = n
            }
            return r(e, [{
                key: "search",
                value: function() {}
            }], [{
                key: "isMultiMatch",
                value: function(e) {
                    return F(e, this.multiRegex)
                }
            }, {
                key: "isSingleMatch",
                value: function(e) {
                    return F(e, this.singleRegex)
                }
            }]), e
        }();

    function F(e, t) {
        var n = e.match(t);
        return n ? n[1] : null
    }
    var N = function(e) {
            s(i, e);
            var n = l(i);

            function i(e) {
                return t(this, i), n.call(this, e)
            }
            return r(i, [{
                key: "search",
                value: function(e) {
                    for (var t, n = 0, r = [], i = this.pattern.length;
                        (t = e.indexOf(this.pattern, n)) > -1;) n = t + i, r.push([t, n - 1]);
                    var o = !!r.length;
                    return {
                        isMatch: o,
                        score: o ? 1 : 0,
                        indices: r
                    }
                }
            }], [{
                key: "type",
                get: function() {
                    return "exact"
                }
            }, {
                key: "multiRegex",
                get: function() {
                    return /^'"(.*)"$/
                }
            }, {
                key: "singleRegex",
                get: function() {
                    return /^'(.*)$/
                }
            }]), i
        }(P),
        D = function(e) {
            s(i, e);
            var n = l(i);

            function i(e) {
                return t(this, i), n.call(this, e)
            }
            return r(i, [{
                key: "search",
                value: function(e) {
                    var t = -1 === e.indexOf(this.pattern);
                    return {
                        isMatch: t,
                        score: t ? 0 : 1,
                        indices: [0, e.length - 1]
                    }
                }
            }], [{
                key: "type",
                get: function() {
                    return "inverse-exact"
                }
            }, {
                key: "multiRegex",
                get: function() {
                    return /^!"(.*)"$/
                }
            }, {
                key: "singleRegex",
                get: function() {
                    return /^!(.*)$/
                }
            }]), i
        }(P),
        z = function(e) {
            s(i, e);
            var n = l(i);

            function i(e) {
                return t(this, i), n.call(this, e)
            }
            return r(i, [{
                key: "search",
                value: function(e) {
                    var t = e.startsWith(this.pattern);
                    return {
                        isMatch: t,
                        score: t ? 0 : 1,
                        indices: [0, this.pattern.length - 1]
                    }
                }
            }], [{
                key: "type",
                get: function() {
                    return "prefix-exact"
                }
            }, {
                key: "multiRegex",
                get: function() {
                    return /^\^"(.*)"$/
                }
            }, {
                key: "singleRegex",
                get: function() {
                    return /^\^(.*)$/
                }
            }]), i
        }(P),
        q = function(e) {
            s(i, e);
            var n = l(i);

            function i(e) {
                return t(this, i), n.call(this, e)
            }
            return r(i, [{
                key: "search",
                value: function(e) {
                    var t = !e.startsWith(this.pattern);
                    return {
                        isMatch: t,
                        score: t ? 0 : 1,
                        indices: [0, e.length - 1]
                    }
                }
            }], [{
                key: "type",
                get: function() {
                    return "inverse-prefix-exact"
                }
            }, {
                key: "multiRegex",
                get: function() {
                    return /^!\^"(.*)"$/
                }
            }, {
                key: "singleRegex",
                get: function() {
                    return /^!\^(.*)$/
                }
            }]), i
        }(P),
        W = function(e) {
            s(i, e);
            var n = l(i);

            function i(e) {
                return t(this, i), n.call(this, e)
            }
            return r(i, [{
                key: "search",
                value: function(e) {
                    var t = e.endsWith(this.pattern);
                    return {
                        isMatch: t,
                        score: t ? 0 : 1,
                        indices: [e.length - this.pattern.length, e.length - 1]
                    }
                }
            }], [{
                key: "type",
                get: function() {
                    return "suffix-exact"
                }
            }, {
                key: "multiRegex",
                get: function() {
                    return /^"(.*)"\$$/
                }
            }, {
                key: "singleRegex",
                get: function() {
                    return /^(.*)\$$/
                }
            }]), i
        }(P),
        J = function(e) {
            s(i, e);
            var n = l(i);

            function i(e) {
                return t(this, i), n.call(this, e)
            }
            return r(i, [{
                key: "search",
                value: function(e) {
                    var t = !e.endsWith(this.pattern);
                    return {
                        isMatch: t,
                        score: t ? 0 : 1,
                        indices: [0, e.length - 1]
                    }
                }
            }], [{
                key: "type",
                get: function() {
                    return "inverse-suffix-exact"
                }
            }, {
                key: "multiRegex",
                get: function() {
                    return /^!"(.*)"\$$/
                }
            }, {
                key: "singleRegex",
                get: function() {
                    return /^!(.*)\$$/
                }
            }]), i
        }(P),
        K = function(e) {
            s(i, e);
            var n = l(i);

            function i(e) {
                var r, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    c = o.location,
                    s = void 0 === c ? _.location : c,
                    a = o.threshold,
                    u = void 0 === a ? _.threshold : a,
                    h = o.distance,
                    f = void 0 === h ? _.distance : h,
                    l = o.includeMatches,
                    d = void 0 === l ? _.includeMatches : l,
                    v = o.findAllMatches,
                    y = void 0 === v ? _.findAllMatches : v,
                    g = o.minMatchCharLength,
                    p = void 0 === g ? _.minMatchCharLength : g,
                    m = o.isCaseSensitive,
                    k = void 0 === m ? _.isCaseSensitive : m;
                return t(this, i), (r = n.call(this, e))._bitapSearch = new R(e, {
                    location: s,
                    threshold: u,
                    distance: f,
                    includeMatches: d,
                    findAllMatches: y,
                    minMatchCharLength: p,
                    isCaseSensitive: k
                }), r
            }
            return r(i, [{
                key: "search",
                value: function(e) {
                    return this._bitapSearch.searchIn(e)
                }
            }], [{
                key: "type",
                get: function() {
                    return "fuzzy"
                }
            }, {
                key: "multiRegex",
                get: function() {
                    return /^"(.*)"$/
                }
            }, {
                key: "singleRegex",
                get: function() {
                    return /^(.*)$/
                }
            }]), i
        }(P),
        T = [N, z, q, J, W, D, K],
        U = T.length,
        B = / +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;

    function G(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return e.split("|").map((function(e) {
            for (var n = e.trim().split(B).filter((function(e) {
                    return e && !!e.trim()
                })), r = [], i = 0, o = n.length; i < o; i += 1) {
                for (var c = n[i], s = !1, a = -1; !s && ++a < U;) {
                    var u = T[a],
                        h = u.isMultiMatch(c);
                    h && (r.push(new u(h, t)), s = !0)
                }
                if (!s)
                    for (a = -1; ++a < U;) {
                        var f = T[a],
                            l = f.isSingleMatch(c);
                        if (l) {
                            r.push(new f(l, t));
                            break
                        }
                    }
            }
            return r
        }))
    }
    var H = new Set([K.type, N.type]),
        Q = function() {
            function e(n) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    i = r.isCaseSensitive,
                    o = void 0 === i ? _.isCaseSensitive : i,
                    c = r.includeMatches,
                    s = void 0 === c ? _.includeMatches : c,
                    a = r.minMatchCharLength,
                    u = void 0 === a ? _.minMatchCharLength : a,
                    h = r.findAllMatches,
                    f = void 0 === h ? _.findAllMatches : h,
                    l = r.location,
                    d = void 0 === l ? _.location : l,
                    v = r.threshold,
                    y = void 0 === v ? _.threshold : v,
                    g = r.distance,
                    p = void 0 === g ? _.distance : g;
                t(this, e), this.query = null, this.options = {
                    isCaseSensitive: o,
                    includeMatches: s,
                    minMatchCharLength: u,
                    findAllMatches: f,
                    location: d,
                    threshold: y,
                    distance: p
                }, this.pattern = o ? n : n.toLowerCase(), this.query = G(this.pattern, this.options)
            }
            return r(e, [{
                key: "searchIn",
                value: function(e) {
                    var t = this.query;
                    if (!t) return {
                        isMatch: !1,
                        score: 1
                    };
                    var n = this.options,
                        r = n.includeMatches;
                    e = n.isCaseSensitive ? e : e.toLowerCase();
                    for (var i = 0, o = [], c = 0, s = 0, a = t.length; s < a; s += 1) {
                        var u = t[s];
                        o.length = 0, i = 0;
                        for (var h = 0, f = u.length; h < f; h += 1) {
                            var l = u[h],
                                v = l.search(e),
                                y = v.isMatch,
                                g = v.indices,
                                p = v.score;
                            if (!y) {
                                c = 0, i = 0, o.length = 0;
                                break
                            }
                            if (i += 1, c += p, r) {
                                var m = l.constructor.type;
                                H.has(m) ? o = [].concat(d(o), d(g)) : o.push(g)
                            }
                        }
                        if (i) {
                            var k = {
                                isMatch: !0,
                                score: c / i
                            };
                            return r && (k.indices = o), k
                        }
                    }
                    return {
                        isMatch: !1,
                        score: 1
                    }
                }
            }], [{
                key: "condition",
                value: function(e, t) {
                    return t.useExtendedSearch
                }
            }]), e
        }(),
        V = [];

    function X(e, t) {
        for (var n = 0, r = V.length; n < r; n += 1) {
            var i = V[n];
            if (i.condition(e, t)) return new i(e, t)
        }
        return new R(e, t)
    }
    var Y = "$and",
        Z = "$or",
        ee = function(e) {
            return !(!e[Y] && !e[Z])
        },
        te = function(t) {
            return !y(t) && "object" === e(t) && !ee(t)
        },
        ne = function(e) {
            return i({}, Y, Object.keys(e).map((function(t) {
                return i({}, t, e[t])
            })))
        },
        re = function() {
            function e(n) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    i = arguments.length > 2 ? arguments[2] : void 0;
                t(this, e), this.options = c({}, _, {}, r), this.options.useExtendedSearch, this._keyStore = new S(this.options.keys), this.setCollection(n, i)
            }
            return r(e, [{
                key: "setCollection",
                value: function(e, t) {
                    if (this._docs = e, t && !(t instanceof C)) throw new Error("Incorrect 'index' type");
                    this._myIndex = t || L(this._keyStore.keys(), this._docs, {
                        getFn: this.options.getFn
                    })
                }
            }, {
                key: "add",
                value: function(e) {
                    m(e) && (this._docs.push(e), this._myIndex.add(e))
                }
            }, {
                key: "removeAt",
                value: function(e) {
                    this._docs.splice(e, 1), this._myIndex.removeAt(e)
                }
            }, {
                key: "getIndex",
                value: function() {
                    return this._myIndex
                }
            }, {
                key: "search",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = t.limit,
                        r = void 0 === n ? -1 : n,
                        i = this.options,
                        o = i.includeMatches,
                        c = i.includeScore,
                        s = i.shouldSort,
                        a = i.sortFn,
                        u = g(e) ? g(this._docs[0]) ? this._searchStringList(e) : this._searchObjectList(e) : this._searchLogical(e);
                    return ie(u, this._keyStore), s && u.sort(a), p(r) && r > -1 && (u = u.slice(0, r)), oe(u, this._docs, {
                        includeMatches: o,
                        includeScore: c
                    })
                }
            }, {
                key: "_searchStringList",
                value: function(e) {
                    var t = X(e, this.options),
                        n = this._myIndex.records,
                        r = [];
                    return n.forEach((function(e) {
                        var n = e.v,
                            i = e.i,
                            o = e.n;
                        if (m(n)) {
                            var c = t.searchIn(n),
                                s = c.isMatch,
                                a = c.score,
                                u = c.indices;
                            s && r.push({
                                item: n,
                                idx: i,
                                matches: [{
                                    score: a,
                                    value: n,
                                    norm: o,
                                    indices: u
                                }]
                            })
                        }
                    })), r
                }
            }, {
                key: "_searchLogical",
                value: function(e) {
                    var t = this,
                        n = function(e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                                r = n.auto,
                                i = void 0 === r || r,
                                o = function e(n) {
                                    var r = Object.keys(n);
                                    if (r.length > 1 && !ee(n)) return e(ne(n));
                                    var o = r[0];
                                    if (te(n)) {
                                        var c = n[o];
                                        if (!g(c)) throw new Error(M(o));
                                        var s = {
                                            key: o,
                                            pattern: c
                                        };
                                        return i && (s.searcher = X(c, t)), s
                                    }
                                    var a = {
                                        children: [],
                                        operator: o
                                    };
                                    return r.forEach((function(t) {
                                        var r = n[t];
                                        y(r) && r.forEach((function(t) {
                                            a.children.push(e(t))
                                        }))
                                    })), a
                                };
                            return ee(e) || (e = ne(e)), o(e)
                        }(e, this.options),
                        r = this._myIndex,
                        i = r.keys,
                        o = r.records,
                        c = {},
                        s = [];
                    return o.forEach((function(e) {
                        var r = e.$,
                            o = e.i;
                        m(r) && function e(n, r, o) {
                            if (!n.children) {
                                var a = n.key,
                                    u = n.searcher,
                                    h = r[i.indexOf(a)];
                                return t._findMatches({
                                    key: a,
                                    value: h,
                                    searcher: u
                                })
                            }
                            for (var f = n.operator, l = [], v = 0; v < n.children.length; v += 1) {
                                var y = e(n.children[v], r, o);
                                if (y && y.length) {
                                    if (l.push({
                                            idx: o,
                                            item: r,
                                            matches: y
                                        }), f === Z) break
                                } else if (f === Y) {
                                    l.length = 0;
                                    break
                                }
                            }
                            l.length && (c[o] || (c[o] = {
                                idx: o,
                                item: r,
                                matches: []
                            }, s.push(c[o])), l.forEach((function(e) {
                                var t, n = e.matches;
                                (t = c[o].matches).push.apply(t, d(n))
                            })))
                        }(n, r, o)
                    })), s
                }
            }, {
                key: "_searchObjectList",
                value: function(e) {
                    var t = this,
                        n = X(e, this.options),
                        r = this._myIndex,
                        i = r.keys,
                        o = r.records,
                        c = [];
                    return o.forEach((function(e) {
                        var r = e.$,
                            o = e.i;
                        if (m(r)) {
                            var s = [];
                            i.forEach((function(e, i) {
                                s.push.apply(s, d(t._findMatches({
                                    key: e,
                                    value: r[i],
                                    searcher: n
                                })))
                            })), s.length && c.push({
                                idx: o,
                                item: r,
                                matches: s
                            })
                        }
                    })), c
                }
            }, {
                key: "_findMatches",
                value: function(e) {
                    var t = e.key,
                        n = e.value,
                        r = e.searcher;
                    if (!m(n)) return [];
                    var i = [];
                    if (y(n)) n.forEach((function(e) {
                        var n = e.v,
                            o = e.i,
                            c = e.n;
                        if (m(n)) {
                            var s = r.searchIn(n),
                                a = s.isMatch,
                                u = s.score,
                                h = s.indices;
                            a && i.push({
                                score: u,
                                key: t,
                                value: n,
                                idx: o,
                                norm: c,
                                indices: h
                            })
                        }
                    }));
                    else {
                        var o = n.v,
                            c = n.n,
                            s = r.searchIn(o),
                            a = s.isMatch,
                            u = s.score,
                            h = s.indices;
                        a && i.push({
                            score: u,
                            key: t,
                            value: o,
                            norm: c,
                            indices: h
                        })
                    }
                    return i
                }
            }]), e
        }();

    function ie(e, t) {
        e.forEach((function(e) {
            var n = 1;
            e.matches.forEach((function(e) {
                var r = e.key,
                    i = e.norm,
                    o = e.score,
                    c = t.get(r, "weight");
                n *= Math.pow(0 === o && c ? Number.EPSILON : o, (c || 1) * i)
            })), e.score = n
        }))
    }

    function oe(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = n.includeMatches,
            i = void 0 === r ? _.includeMatches : r,
            o = n.includeScore,
            c = void 0 === o ? _.includeScore : o,
            s = [];
        return i && s.push(j), c && s.push(A), e.map((function(e) {
            var n = e.idx,
                r = {
                    item: t[n],
                    refIndex: n
                };
            return s.length && s.forEach((function(t) {
                t(e, r)
            })), r
        }))
    }
    return re.version = "6.0.4", re.createIndex = L, re.parseIndex = function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                n = t.getFn,
                r = void 0 === n ? _.getFn : n,
                i = e.keys,
                o = e.records,
                c = new C({
                    getFn: r
                });
            return c.setKeys(i), c.setRecords(o), c
        }, re.config = _,
        function() {
            V.push.apply(V, arguments)
        }(Q), re
}, "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).Fuse = t();

</script>
<style>
    html,
    body {
        margin: 0;
        width: "100vw";
        height: "100vh";
    }

    body {
        background-color: #ffffff
    }

    #container {
        display: flex;
        justify-content: center;
        padding: 5rem;
    }

    #buttons-group {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
    }
    #question {
        width: 100%;
    }
</style>

<body>
    <div id="container">
        <div>
            <button onclick="window.location.href='secondIndex.html'">switch to MAA</button>
            <textarea id="question" rows="5" cols="50" placeholder="Enter here a question..."></textarea>
            <div id="buttons-group">
                <button id="search">Search</button>
                <button id="clear">Clear</button>
            </div>
            Answers:
            <div id="answer-list">

            </div>
        </div>
    </div>
</body>

<script>
const buttonSearch = document.querySelector('#search');
buttonSearch.addEventListener("click", searchFunction);

function searchFunction() {
    clearAnswers(); 
    var questions = [


            // TAK NIE
"W hierarchicznym systemie plikow wystepuje wiele katalogow glownych\n[ ] TAK\n[X] NIE",
"W hierarchicznym systemie plikow uzytkownikom przypisane sa priorytety dostepu do plikow\n[ ] TAK\n[X] NIE",
"W hierarchicznym systemie plikow uzytkownicy maja dostep tylko do swoich plikow\n[ ] TAK\n[X] NIE",
"W hierarchicznym systemie plikow okresla sie sciezki dostepu do plikow\n[X] TAK\n[ ] NIE",
"W hierarchicznym systemie plikow wystepuje jeden katalog glowny\n[X] TAK\n[ ] NIE","W hierarchicznym systemie plikow okreslona jest dokladnie jedna sciezka bezwzgledna do pliku\n[X] TAK\n[ ] NIE","W hierarchicznym systemie plikow wystepuja sciezki wzgledne i bezwzgledne dostepu do plikow\n[X] TAK\n[ ] NIE","W hierarchicznym systemie plikow moga wystepowac wielokrotne dowiazania twarde do pliku\n[X] TAK\n[ ] NIE","Bloki alokacji (klastry) w systemie plikow dobierane sa tak, aby zminimalizowac fragmentacje\nzewnetrzna\n[ ] TAK\n[X] NIE","Bloki alokacji (klastry) w systemie plikow dobierane sa tak, aby zminimalizowac fragmentacje\nwewnetrzna\n[X] TAK\n[ ] NIE","Bloki alokacji (klastry) w systemie plikow sa stalej wielkosci w calym systemie plikow\n[X] TAK\n[ ] NIE","Bloki alokacji (klastry) w systemie plikow sa zawsze wielkosci dwoch rekordow fizycznych (sektorow)\nna dysku\n[ ] TAK\n[X] NIE","Bloki alokacji (klastry) w systemie plikow powinny byc jak najwieksze, aby bylo ich w systemie\nniewiele\n[ ] TAK\n[X] NIE","Bloki alokacji (klastry) w systemie plikow numerowane sa liczbami binarnymi stalej dlugosci, co\nogranicza ich liczbe\n[X] TAK\n[ ] NIE","Sekwencyjny dostep do pliku polega na czytaniu lub zapisie pliku rekord po rekordzie w stalej\nkolejnosci\n[X] TAK\n[ ] NIE","Sekwencyjny dostep do pliku pozwala na wystepowanie plikow nieciaglych, z niezaalokowanymi\ndziurami\n[ ] TAK\n[X] NIE","Sekwencyjny dostep do pliku jest mozliwy tylko w plikach z rekordami stalej dlugosci\n[ ] TAK\n[X] NIE","Sekwencyjny dostep do pliku nie pozwala dopisywac rekordow na koniec istniejacego pliku\n[ ] TAK\n[X] NIE","Sekwencyjny dostep do pliku nie powinien byz uzywany - jest implementowany jedynie z przyczyn\nhistorycznych\n[ ] TAK\n[X] NIE","Sekwencyjny dostep do pliku pozwala czytac rekordy w dowolnej kolejnosci dzieki operacji lseek\n[ ] TAK\n[X] NIE","Sekwencyjny dostep do pliku wyklucza powstawanie dziur w plikach, w ktorych nie ma\nprzydzielonych blokow\n[X] TAK\n[ ] NIE",
"Sekwencyjny dostep do pliku ulatwia grupowanie operacji dyskowych przez system operacyjny\n[X] TAK\n[ ] NIE","Sekwencyjny dostep do pliku powinien byc uzywany jedynie przy operacjach na plikach specjalnych,\nodpowiadajacych urzadzeniom znakowym\n[ ] TAK\n[X] NIE","Sekwencyjny dostep do pliku szereguje dostep wielu procesow do pliku\n[ ] TAK\n[X] NIE","Bezposredni==swobodny dostep do pliku wymaga zmiany kolejnosci rekordow w pliku w celu\noptymalizacji czas dostepu\n[ ] TAK\n[X] NIE","Bezposredni==swobodny dostep do pliku pozwala na wystepowanie plikow nieciaglych, wewnatrz\nktorych moga wystapic niezaalokowane obszary\n[X] TAK\n[ ] NIE","Bezposredni==swobodny dostep do pliku jest mozliwy tylko w plikach z rekordami stalej dlugosci\n[X] TAK\n[ ] NIE","Bezposredni==swobodny dostep do pliku pozwala na wystepowanie plikow nieciaglych, z\nniezaalokowanymi dziurami\n[X] TAK\n[ ] NIE","Bezposredni==swobodny dostep do pliku pozwala czytac rekordy w dowolnej kolejnosci dzieki\noperacji lseek\n[X] TAK\n[ ] NIE","Bezposredni==swobodny dostep do pliku pozwala na zapis fragmentow roznych plikow do wspolnego\nbloku alokacji\n[ ] TAK\n[X] NIE","Bezposredni==swobodny dostep do pliku szereguje dostep wielu procesow do pliku\n[ ] TAK\n[X] NIE","Bezposredni==swobodny dostep do pliku blokuje rownoczesny dostep wielu procesow do pliku\n[ ] TAK\n[X] NIE","W unixie wystepuje katalog, dostepny przez sciezke ../ jest to katalog roboczy procesu\n[ ] TAK\n[X] NIE","W unixie wystepuje katalog, dostepny przez sciezke ../ jest to katalog nadrzedny\n[X] TAK\n[ ] NIE","W unixie wystepuje katalog, dostepny przez sciezke ../ jest to katalog glowny, jeden dla calego\nsystemu\n[ ] TAK\n[X] NIE","W unixie wystepuje katalog, dostepny przez sciezke ../ kazdy proces moze miec swoj taki katalog\n[X] TAK\n[ ] NIE","W unixie wystepuje katalog, dostepny przez sciezke ../ proces musi miec prawa zapisu w tym\nkatalogu, aby mogl sie wykonywac\n[ ] TAK\n[X] NIE","Przydzial ciagly miejsca na dysku jest algorytmem optymalnym, nie dajacym sie zaimplementowac w\npraktyce\n[ ] TAK\n[X] NIE","Przydzial ciagly miejsca na dysku charakteryzuje sie fragmentacja zewnetrzna przestrzeni dysku\n[X] TAK\n[ ] NIE","Przydzial ciagly miejsca na dysku wymaga zapisu tablicy indeksowej na dysku\n[ ] TAK\n[X] NIE","Przydzial indeksowy miejsca na dysku jest algorytmem optymalnym, nie dajacym sie\nzaimplementowac w praktyce\n[ ] TAK\n[X] NIE","Przydzial indeksowy miejsca na dysku charakteryzuje sie fragmentacja zewnetrzna przestrzeni dysku\n[ ] TAK\n[X] NIE","Przydzial indeksowy miejsca na dysku wymaga zapisu tablicy indeksowej na dysku\n[X] TAK\n[ ] NIE","Przydzial listowy miejsca na dysku jest algorytmem optymalnym, nie dajacym sie zaimplementowac\nw praktyce\n[ ] TAK\n[X] NIE","Przydzial listowy miejsca na dysku charakteryzuje sie brakiem fragmentacja wewnetrznej przestrzeni\ndysku\n[ ] TAK\n[X] NIE","Przydzial listowy miejsca na dysku wymaga zapisu tablicy listowej na dysku\n[ ] TAK\n[X] NIE","Planowanie krotkoterminowe wymaga architektury wieloproces orowej\n[ ] TAK\n[X] NIE","Planowanie krotkoterminowe bezposrednio decyduje o wyborze procesow, ktore nalezy wczytac do\npamieci\n[ ] TAK\n[X] NIE","Planowanie krotkoterminowe okresla procesy, ktore nalezy zablokowac\n[ ] TAK\n[X] NIE","Planowanie srednioterminowe wymaga architektury wieloprocesorowej\n[ ] TAK\n[X] NIE","Planowanie srednioterminowe bezposrednio decyduje o wyborze procesow, ktore nalezy wczytac do\npamieci\n[X] TAK\n[ ] NIE","Planowanie srednioterminowe okresla procesy, ktore nalezy zablokowac\n[X] TAK\n[ ] NIE","Planowanie srednioterminowe polega na wyborze procesu, ktory ma zostac usuniety z pamieci op\n[X] TAK\n[ ] NIE","Planowanie srednioterminowe to wybor zadania, ktore w pierwszej kolejnosci powinno zostac\nwczytane do pamieci op\n[X] TAK\n[ ] NIE","Planowanie srednioterminowe musi byc zaimplementowane w kazdym wieloprogramowym sO\n[ ] TAK\n[X] NIE","Planowanie dlugoterminowe wymaga architektury wieloprocesorowej\n[ ] TAK\n[X] NIE","Planowanie dlugoterminowe bezposrednio decyduje o wyborze procesow, ktore nalezy wczytac do\npamieci\n[X] TAK\n[ ] NIE","Planowanie dlugoterminowe okresla procesy, ktore nalezy utworzyc\n[X] TAK\n[ ] NIE","Spooling to technika przydzielania dodatkowych buforow procesom uprzywilejowanym\n[ ] TAK\n[X] NIE",
"Spooling to technika kopiowania w tle danych z nosnika papierowego na szybszy magnetyczny\n[X] TAK\n[ ] NIE","Spooling to technika programowania, zmniejszjaca pamiec wymagana do wykonania programu\n[ ] TAK\n[X] NIE","Spooling eliminuje fragmentacje zewnetrzna dyskow przez przesuwanie plikow w trakcie normalnej\npracy komputera (w tle)\n[ ] TAK\n[X] NIE","Spooling eliminuje fragmentacje zewnetrzna dyskow przez przesuwanie plikow, przy czym\nuruchamiany jest przy\n[ ] TAK\n[X] NIE","Spooling wylaczonych wszystkich innych procesach\n[ ] TAK\n[X] NIE","Spooling to metoda buforowania dysku bazujaca na tworzeniu duzych puli buforow systemowych\n[ ] TAK\n[X] NIE","Spooling to metoda buforowania dysku w szybkich pamieciach wbudowanych do sterownika\n[ ] TAK\n[X] NIE","Spooling polega na zapisie danych wyjsciowych z programu na szybkie nosniki magnetyczne i\ndrukowaniu ich w tle po zakonczeniu programu\n[X] TAK\n[ ] NIE","W unixie wystepuje katalog, dostepny przez sciezke ./ jest to katalog roboczy procesu\n[X] TAK\n[ ] NIE","W unixie wystepuje katalog, dostepny przez sciezke ./ jest to katalog nadrzedny\n[ ] TAK\n[X] NIE","W unixie wystepuje katalog, dostepny przez sciezke ./ jest to katalog glowny, jeden dla calego\nsystemu\n[ ] TAK\n[X] NIE","W unixie wystepuje katalog, dostepny przez sciezke ./ kazdy proces moze miec swoj taki katalog\n[X] TAK\n[ ] NIE","W unixie wystepuje katalog, dostepny przez sciezke ./ proces musi miec prawa zapisu w tym\nkatalogu, aby mogl sie wykonywac\n[ ] TAK\n[X] NIE","Katalog glowny systemu plikow w unixie jest plikiem zawierajacym rekordy z nazwami i numerami\ninode\xadow nalezacych do niego plikow\n[X] TAK\n[ ] NIE","Katalog glowny systemu plikow w unixie jest plikiem zawierajacym rekordy z nazwami, innymi\natrybutami i tablicami indeksowymi nalezacych do niego plikow\n[ ] TAK\n[X] NIE","Katalog glowny systemu plikow w unixie nie ma nazwy, definiowany jest przez zapisanie numeru jego\ninode\xadu w superbloku\n[ ] TAK\n[X] NIE","Katalog glowny systemu plikow w unixie nie ma nazwy, zajmuje zawsze to samo miejsce na partycji\ndysku (w systemie plikow)\n[ ] TAK\n[X] NIE","Katalog glowny systemu plikow w unixie ma ograniczona wielkosc, poniewaz umieszczony jest w\ncalosci w superbloku\n[ ] TAK\n[X] NIE","Katalog glowny systemu plikow w unixie nie zawiera pozycji .. (normalnie wskazujacej na katalog\nnadrzedny)\n[ ] TAK\n[X] NIE","Katalog glowny systemu plikow w unixie nie zawiera pozycji . i .. (normalnie wskazujacych na katalog\nbiezacy i nadrzedny)\n[ ] TAK\n[X] NIE","Katalog glowny systemu plikow w unixie zawiera stala liczbe pozycji, ktorej nie mozna zmienic bez\nrekompilacji jadra systemu\n[ ] TAK\n[X] NIE","Katalog glowny systemu plikow w unixie musi miec taka sama zawartosc, jak katalog do ktorego jest\nmontowany\n[ ] TAK\n[X] NIE","Katalog biezacy w unixie jest plikiem zawierajacym rekordy z nazwami i numerami inode\xadow\nnalezacych do niego plikow\n[X] TAK\n[ ] NIE","Katalog biezacy w unixie ma ograniczona wielkosc, poniewaz umieszczony jest w calosci w\nsuperbloku\n[ ] TAK\n[X] NIE","Katalog biezacy w unixie nie zawiera pozycji . i ..\n[ ] TAK\n[X] NIE","Katalog biezacy w unixie uzytkwnik nie moze zmienic go, jezeli nie ma uprawnien root\n[ ] TAK\n[X] NIE","Powloka systemu operacyjnego okresla dostepny zestaw i skladnie komend sterujacych\n[X] TAK\n[ ] NIE","Powloka systemu operacyjnego okresla dostepny zestaw i skladnie komend zewnetrznych\n[ ] TAK\n[X] NIE","Powloka systemu operacyjnego okresla dostepny zestaw i skladnie komend wewnetrznych\n[X] TAK\n[ ] NIE","Powloka systemu operacyjnego okresla zmienne srodowiskowe dla uruchamianych komend\n[X] TAK\n[ ] NIE","Powloka systemu operacyjnego okresla jezyk programowania skryptow systemowych\n[X] TAK\n[ ] NIE","Powloka systemu operacyjnego pozwala na edytowanie linii komendy\n[X] TAK\n[ ] NIE","Powloka systemu operacyjnego pozwala na przegladanie historii wykonywanych komend\n[X] TAK\n[ ] NIE","Listy kontroli dostepu ACL w windows NT sluza do okreslania warunkow logowania uzytkownikow do\nsystemu\n[ ] TAK\n[X] NIE","Listy kontroli dostepu ACL w windows NT sluza do okreslania warunkow dostepu do plikow dla\nroznych uzytkownikow\n[X] TAK\n[ ] NIE","Listy kontroli dostepu ACL w windows NT pozwalaja definiowac grupy uzytkownikow\n[X] TAK\n[ ] NIE","Listy kontroli dostepu ACL w windows NT pozwalaja definiowac klucze dostepu do zasobow\n[ ] TAK\n[X] NIE","Listy kontroli dostepu ACL w windows NT umozliwiaja zdefiniowanie obiektow, do ktorych dostep\nmusi byc odnotowany\n[X] TAK\n[ ] NIE","Plik MFT (Master file table) w systemie plikow NTFS sluzy do okreslania uprawnien dostepu do plikow\n[ ] TAK\n[X] NIE","Plik MFT (Master file table) w systemie plikow NTFS sluzy do okreslania warunkow logowania\nuzytkownikow do sytemu\n[ ] TAK\n[X] NIE","Plik MFT (Master file table) w systemie plikow NTFS zawiera listy ACL wszystkich plikow\n[X] TAK\n[ ] NIE","Plik MFT (Master file table) w systemie plikow NTFS zawiera kopie boot sektora\n[ ] TAK\n[X] NIE","Plik MFT (Master file table) w systemie plikow NTFS zawiera opis wszystkich plikow w systemie\n[X] TAK\n[ ] NIE","Plik MFT (Master file table) w systemie plikow NTFS zawiera tablice partycji dysku\n[ ] TAK\n[X] NIE","Tablica FAT w systemie MS-DOS zawiera osobna pozycje dla kazdego rekordu fizycznego (sektora) w\npartycji dysku\n[ ] TAK\n[X] NIE","Tablica FAT w systemie MS-DOS zawiera informacje o defektach nosnika w pamieci dyskowej\n[X] TAK\n[ ] NIE","Tablica FAT w systemie MS-DOS pozwala przydzielac rekordy rezerwowe w miejsce uszkodzonych\n[ ] TAK\n[X] NIE","Tablica FAT w systemie MS-DOS zastepuje mape zajetosci dysku\n[X] TAK\n[ ] NIE","Semafory binarne sluza do wyznaczania czasu w systemach czasu rzeczywistego\n[ ] TAK\n[X] NIE","Semafory binarne sluza do synchronizacji procesow wspolbieznych\n[X] TAK\n[ ] NIE","Semafory binarne sluza do blokowania dostepu do dysku w trybie binarnym (nie znakowym)\n[ ] TAK\n[X] NIE","Semafory binarne sa to struktury danych do modelowania ruchu ulicznego\n[ ] TAK\n[X] NIE","Semafory binarne sa to dane jednobitowe, ktore mozna testowac, ustawiac i zerowac\n[X] TAK\n[ ] NIE","Semafory binarne sa to dane calkowitoliczbowe z zakresu 0 - 2n (n>1) z niepodzielnymi operacjami p i\nV\n[ ] TAK\n[X] NIE","Semafory binarne mozna uzywac do rozwiazywania dowolnych problemow synchronizacji procesow\n[X] TAK\n[ ] NIE","W semaforach dijkstry operacja czekaj na tych semaforach zawsze usypia procesy\n[X] TAK\n[ ] NIE","W semaforach dijkstry operacja sygnalizuj na tych semaforach moze usypiac procesy\n[ ] TAK\n[X] NIE","Semafory dijkstry sa mechanizmem ograniczajacym dostep do plikow\n[ ] TAK\n[X] NIE","Semafory dijkstry sluza do synchronizacji procesow\n[X] TAK\n[ ] NIE","Semafory dijkstry sluza do synchronizacji procesow wspolbieznych\n[X] TAK\n[ ] NIE","Semafory dijkstry to struktury danych do modelowania ruchu ulicznego\n[ ] TAK\n[X] NIE","Semafory dijkstry sa mechanizmem synchronizujacym dostep do plikow\n[X] TAK\n[ ] NIE","Semafory dijkstry sa to dane calkowitoliczbowe, na ktorych zdefiniowane sa operacje p i V\n[X] TAK\n[ ] NIE","Semafory dijkstry sa to flagi dwustanowe, na ktorych zdefiniowane sa nieprzerywalne operacje p i V\n[ ] TAK\n[X] NIE","Semafory dijkstry mozna uzywac do rozwiazywania dowolnych problemow synchronizacji procesow\n[X] TAK\n[ ] NIE","Semafory dijkstry w ich implementacji stosuje sie petle goracego czekania\n[ ] TAK\n[X] NIE","Kontekst procesu okresla wszystkie zasoby, z ktorych moze proces korzystac\n[ ] TAK\n[X] NIE","Kontekst procesu okresla wszystkie procesy, z ktorymi moze sie komunikowac\n[ ] TAK\n[X] NIE","Kontekst procesu okresla zawartosc rejestrow, z ktorych proces moze korzystac\n[X] TAK\n[ ] NIE","Kontekst procesu obejmuje informacje konieczne do wznowienia procesu zablokowanego\n[X] TAK\n[ ] NIE","Kontekst procesu obejmuje informacje konieczne do ustalenia procesu nadrzednego\n[ ] TAK\n[X] NIE","Kontekst procesu jest to obraz pamieci procesu w pewnej chwili\n[ ] TAK\n[X] NIE","Kontekst procesu jest to miedzy innymi obraz pamieci procesu w chwili wstrzymania\n[ ] TAK\n[X] NIE","Kontekst procesu obejmuje informacje konieczne do wznowienia procesu wstrzymanego\n[X] TAK\n[ ] NIE","Kontekst procesu jest to obraz plikow otwartych przez proces w pewnej chwili\n[ ] TAK\n[X] NIE","Kontekst procesu jest to obraz pamieci, rejestrow i zmiennych systemowych procesu w pewnej chwili\n[ ] TAK\n[X] NIE","Kontekst procesu jest skladowany gdy proces sie konczy (wykonuje exit)\n[ ] TAK\n[X] NIE","Kontekst procesu jest odtwarzany przy kazdym przelaczeniu procesow\n[ ] TAK\n[X] NIE","Kontekst procesu opisuje zaleznosc pomiedzy wspolbieznymi procesami\n[ ] TAK\n[X] NIE","Procesy charakteryzuja sie sekwencyjnym wykonywaniem operacji\n[X] TAK\n[ ] NIE","Procesy charakteryzuja sie kontekstem, ktory okresla jakie procesy sa wykonywane wspolbieznie\n[ ] TAK\n[X] NIE","Procesy charakteryzuja sie zlozonoscia obliczeniowa, wyrazona np. przez liczbe petli, skokow i\nrozgalezien (Nie wiadomo do konca)\n[X] TAK\n[ ] NIE","Procesy charakteryzuja sie mozliwoscia przerywania i wznawiania wykonania (wedlug skladowanego\nkontekstu)\n[X] TAK\n[ ] NIE","Proces moze przejsc do stanu gotowosci po wyczerpaniu kwantu czasu aktywnosci (w systemie z\nalgorytmem karuzelowym)\n[ ] TAK\n[X] NIE","Proces moze przejsc do stanu gotowosci w wyniku wykonania funkcji exit (w unixie)\n[ ] TAK\n[X] NIE","Proces moze przejsc do stanu gotowosci bezposrednio ze stanu zablokowania\n[X] TAK\n[ ] NIE","Proces moze przejsc do stanu zablokowania (uspienia) po wyczerpaniu kwantu czasu aktywnosci (w\nsystemie z algorytmem karuzelowym)\n[X] TAK\n[ ] NIE","Proces moze przejsc do stanu zablokowania (uspienia) w wyniku wykonania funkcji exit (w unixie)\n[ ] TAK\n[X] NIE","Proces moze przejsc do stanu zablokowania (uspienia) bezposrednio ze stanu gotowosci\n[ ] TAK\n[X] NIE","Ochrona pamieci w systemach operacyjnych ogranicza dostep procesow do pamieci systemu\noperacyjnego\n[X] TAK\n[ ] NIE","Ochrona pamieci w systemach operacyjnych ogranicza dostep procesow do pamieci im nie\nprzydzielonej\n[X] TAK\n[ ] NIE","Ochrona pamieci w systemach operacyjnych zapewnia, ze inne procesy nie maja dostepu do pamieci\nprocesu\n[X] TAK\n[ ] NIE","Ochrona pamieci w systemach operacyjnych zapewnia, ze procesy uzytkowe nie moga zmodyfikowac\nobrazu pamieci systemu oper.\n[X] TAK\n[ ] NIE","Ochrona pamieci w systemach operacyjnych bazuje na przeksztalcaniu adresow logicznych na\nfizyczne, kontrolowanym przez sO\n[X] TAK\n[ ] NIE","Ochrona pamieci w systemach operacyjnych bazuje na szyfrowaniu zawartosci pamieci\n[ ] TAK\n[X] NIE","Ochrona pamieci w systemach operacyjnych okresla prawa dostepu procesow do plikow roznych\nwlascicieli\n[ ] TAK\n[X] NIE","Ochrona pamieci w systemach operacyjnych okresla prawa dostepu procesow do folderow poczty\nelektronicznej\n[ ] TAK\n[X] NIE","Stronnicowanie na zadanie to podstawowa technika zwiekszania pamieci widzianej przez programy\n[X] TAK\n[ ] NIE","Stronnicowanie na zadanie to podstawowa technika przyspieszenia dostepu do pamieci\n[ ] TAK\n[X] NIE","Stronnicowanie na zadanie polega na skladowaniu na dysk calego obrazu pamieci zablokowanego\nprocesu\n[ ] TAK\n[X] NIE","Stronnicowanie na zadanie polega na buforowaniu stron pamieci w pamieci podrecznej cache\n[ ] TAK\n[X] NIE","Stronnicowanie na zadanie wymaga dodatkowych pol w tablicy stron (np. flagi waznosci)\n[X] TAK\n[ ] NIE","Stronnicowanie na zadanie wymaga utrzymywania w pamieci tablicy stron\n[X] TAK\n[ ] NIE","Stronnicowanie pamieci polega na przydziale do programu ramek pamieci o stalej wielkosci\n[X] TAK\n[ ] NIE","Stronnicowanie pamieci polega na przydziale do programu segmentow pamieci dowolnej wielkosci\n[ ] TAK\n[X] NIE","Stronnicowanie pamieci wymaga tworzenia obrazu pamieci w obszarze wymiany na dysku\n[ ] TAK\n[X] NIE","Stronnicowanie pamieci pozwala implementowac liniowy model adresow fizycznych w programie\n[ ] TAK\n[X] NIE",
"Stronnicowanie pamieci pozwala implementowac liniowy model adresow logicznych w programie\n[X] TAK\n[ ] NIE",
"Pamiec stronnicowania charakteryzuje sie tym, ze adresy logiczne sa tworzone jako suma adresu\nbazowego i przesuniecia\n[ ] TAK\n[X] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze adresy fizyczne sa sklejeniem pary liczb\nokreslajacych numer ramki stalej dlugosci oraz przesuniecia (offset) w obrebie ramki\n[X] TAK\n[ ] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze adres logiczny jest zlozeniem numeru strony i\nprzesuniecia wzgledem jej poczatku\n[X] TAK\n[ ] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze jezeli strona nie ma przydzielonej ramki fizycznej,\nto wystepuje ablad stronyE; brak przydzialu jest\n[X] TAK\n[ ] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze oznaczony w tablicy stron flaga poprawnosci (valid)\n[ ] TAK\n[X] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze jezeli strona nie ma przydzielonej ramki fizycznej,\nto wystepuje ablad stronyE; brak przydzialu jest oznaczony w tablicy stron bitem ochrony (access\ncontrol)\n[ ] TAK\n[X] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze jezeli strona nie ma przydzielonej ramki fizycznej,\nto wystepuje ablad stronyE; brak przydzialu jest oznaczony w tablicy stron bitem modyfikacji\n(modified flag)\n[ ] TAK\n[X] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze jest technika pozwalajaca przydzielac programom\nwiecej pamieci, niz jest fizycznie zainstalowane w systemie\n[ ] TAK\n[X] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze jest technika pozwalajaca przydzielac programom\npamiec blokami stalej wielkosci (stronami)\n[X] TAK\n[ ] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze adres logiczny jest przeksztalcany na adres fizyczny\nprzez odczytanie numeru ramki z tablicy stron, z pozycji odpowiadajacej numerowi strony\n[X] TAK\n[ ] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze jest technika pozwalajaca przydzielac programom\npamiec blokami zmiennej wielkosci\n[ ] TAK\n[X] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze Eliminuje fragmentacje zewnetrzna pamieci\n[X] TAK\n[ ] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze Eliminuje fragmentacje wewnetrzna pamieci\n[ ] TAK\n[X] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze musi byc realizowa z wykorzystaniem pamieci\nasocjacyjnej na tablice stron\n[ ] TAK\n[X] NIE","Pamiec stronnicowania charakteryzuje sie tym, ze powoduje, ze programy maja nieliniowa przestrzen\nadresowa (fizyczna tak, logiczna nie)\n[X] TAK\n[ ] NIE",
"Pamiec stronnicowania charakteryzuje sie tym, ze wymaga implementacji tablicy segmentow\n(sprzetowo lub programowo)\n[ ] TAK\n[X] NIE","Blokada systemu wystepuje, gdy dwa procesy probuja rownoczesnie pisac do tego samego pliku\n[ ] TAK\n[X] NIE","Blokada systemu wystepuje, gdy dwa procesy probuja rownoczesnie pisac do tego gniazda\nsieciowego\n[ ] TAK\n[X] NIE","Blokada systemu wystepuje tylko w systemach operacyjnych napisanych z bledami\n[ ] TAK\n[X] NIE","Blokada systemu wystepuje tylko w systemach operacyjnych wieloprogramowych\n[X] TAK\n[ ] NIE","Blokade systemu mozna usunac przez wymuszenie zakonczenia wszystkich procesow uspionych\n[X] TAK\n[ ] NIE","Blokade systemu mozna usunac przez czasowe zablokowanie dostepu uzytkownikow do systemu\n[ ] TAK\n[X] NIE","Warunki konieczne do wystapienia blokady to wystepowanie zasobow, ktore nie moga byc\nrownoczesnie wykorzystywane przezwiele procesow\n[X] TAK\n[ ] NIE","Warunki konieczne do wystapienia blokady to brak priorytetow w dostepie do zasobow\n[ ] TAK\n[X] NIE","Warunki konieczne do wystapienia blokady to przelaczanie procesow wedlug algorytmu planowania z\nwywlaszczaniem\n[ ] TAK\n[X] NIE","Warunki konieczne do wystapienia blokady to przelaczanie procesow wedlug algorytmu bez\nwywlaszczania\n[X] TAK\n[ ] NIE","Warunki konieczne do wystapienia blokady to przetrzymywanie i oczekiwanie, tzn. pozwolenie\nprocesom nie bedacym aktywnymi ani gotowymi na zachowanie przydzialu zasobu\n[X] TAK\n[ ] NIE","Warunki konieczne do wystapienia blokady to brak mechanizmu, ktory umozliwialby proceson\nprzyjecie zasobow przydzielonych innym\n[X] TAK\n[ ] NIE","Warunki konieczne do wystapienia blokady to wystepowanie zasobow, ktore nie moga byc\nwspoldzielone\n[X] TAK\n[ ] NIE","Warunki konieczne do wystapienia blokady to brak mechanizmu umozliwiajacego wywlaszczanie\nzasobow od procesow\n[X] TAK\n[ ] NIE","Warunki konieczne do wystapienia blokady to okreslaja, jak pisac programy wielowatkowe aby\nunikac bloakd\n[ ] TAK\n[X] NIE","Warunki konieczne do wystapienia blokady to okreslaja, jak pisac programy wieolprocesowe aby\nunikac bloakd\n[ ] TAK\n[X] NIE","Warunki konieczne do wystapienia blokady to okreslaja, kiedy proces moze przejsc do stanu\nzablokowania\n[ ] TAK\n[X] NIE","Warunki konieczne do wystapienia blokady to mozliwosc zawieszania procesow z przydzielonymi\npewnymi zasobami\n[X] TAK\n[ ] NIE","Funkcja systemowa wait w unixie zawiesza wykonywanie procesu w oczekiwaniu na zakonczenie\nprocesu potomnego\n[X] TAK\n[ ] NIE","Funkcja systemowa wait w unixie zawiesza wykonywanie procesu przez zadany argumentem czas\n[ ] TAK\n[X] NIE","Funkcja systemowa wait w unixie moze byc wykonywana tylko przez procesy daemony\n[ ] TAK\n[X] NIE","Funkcja systemowa wait w unixie moze byc wykonywana tylko przez proces z uprawnieniami root\n[ ] TAK\n[X] NIE","Funkcja systemowa wait w unixie umozliwia czekanie na zakonczenie operacji sieciowych\n[X] TAK\n[ ] NIE","Funkcja systemowa wait w unixie umozliwia czekanie na zakonczenie operacji we/wy\n[X] TAK\n[ ] NIE","Technika opoznionego zapisu na dysk w systemie unix jest metu sieciowym\n[X] TAK\n[ ] NIE","Technika opoznionego zapisu na dysk w systemie unix jest metoda synchronizacji zapisow na dysku\n[ ] TAK\n[X] NIE","Technika opoznionego zapisu na dysk w systemie unix polega na wprowadzeniu petli opozniajacej\nmiedzy kolejnymi rozkazami zapisu\n[X] TAK\n[ ] NIE","Technika opoznionego zapisu na dysk w systemie unix polega na zapisie bufora na dysk, w chwili jego\nzwalniania\n[ ] TAK\n[X] NIE","Technika opoznionego zapisu na dysk w systemie unix moze byc wybiorczo stosowana przez\nprogramowe wlaczanie/wylaczanie funkcja fctl\n[ ] TAK\n[X] NIE","Technika opoznionego zapisu na dysk w systemie unix moze byc wylaczana komenda fctl\n[ ] TAK\n[X] NIE","Buforowanie operacji dyskowych w systemie unix jest ograniczone do urzadzen z niewymiennym\nnosnikiem (np. twardych dyskow); dostep do plikow na dyskietkach nie moze byc buforowany\n[ ] TAK\n[X] NIE","Buforowanie operacji dyskowych w systemie unix redukuje czas dostepu do plikow oraz liczbe\nfizycznych operacji we/wy\n[X] TAK\n[ ] NIE","Buforowanie operacji dyskowych w systemie unix utrudnia rownoczesny dostep do rekordow pliku\nprzez wiele procesow (recordlocking)\n[X] TAK\n[ ] NIE","Buforowanie operacji dyskowych w systemie unix wymaga od programisty uzywania operacji fflush\naby miec pewnosc, ze zmiany w pliku zostana natychmiast zapisane na dysk\n[ ] TAK\n[X] NIE","Sygnaly w systemie unix wykorzystywane sa do synchronizacji procesow\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix wykorzystywane sa m.in. do zabijania procesow\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix moga byc adresowane do wszystkich procesow uzytkownika o znanym uID\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix moga byc adresowane do wszystkich procesow uspionych w systemie\n[ ] TAK\n[X] NIE","Sygnaly w systemie unix mozna definiowac wlasne funkcje obslugi niektorych z nich\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix proces mozna zaprogramowac tak, aby ignorowal wszystkie sygnaly\nprzychodzace\n[ ] TAK\n[X] NIE","Sygnaly w systemie unix wysylane moga byc przez kazdy proces przy pomocy funkcji signal\n[ ] TAK\n[X] NIE","Sygnaly w systemie unix wysylane moga byc przez kazdy proces przy pomocy funkcji kill\n[X] TAK\n[ ] NIE","Fragmentacja wewnetrzna dysku jest wynikiem niedopasowania rozmiaru plikow do wielkosci\nobszarow wolnych (powstajacych przy kasowaniu plikow)\n[X] TAK\n[ ] NIE","Fragmentacja wewnetrzna dysku jest wynikiem niedopasowania rozmiaru plikow do wielokrotnosci\nwielkosci blokow alokacji\n[X] TAK\n[ ] NIE","Fragmentacja wewnetrzna dysku jest wynikiem przydzialu miejsca na dysku porcjami zmiennej\nwielkosci\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku moze byc wyeliminowana przez program defragmentujacy\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku jest wynikiem pozostawania niewykorzystanych fragmentow w\nostatnich blokach plikow\n[X] TAK\n[ ] NIE","Fragmentacja wewnetrzna dysku jest wynikiem przydzialu miejsca na dysku porcjami stalej wielkosci\n[X] TAK\n[ ] NIE","Fragmentacja wewnetrzna dysku jest wynikiem braku konserwacji systemu plikow - moze byc\nwyeliminowana przez program defragmentujacy\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku jest wynikiem braku konserwacji systemu plikow (brak\ndefragmentacji)\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku jest wynikiem bledow programowych np. nie zamkniecia pliku\nprzed zakonczeniem programu\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku powoduje lepsze wykorzystanie miejsca w pamieci przez procesy\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku jest wynikiem przydzialu pamieci porcjami stalej wielkosci\n(stronami)\n[X] TAK\n[ ] NIE","Fragmentacja wewnetrzna dysku wystepuje jedynie w systemach z pamiecia wirtualna\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku jest wynikiem niedopasowania rozmiaru segmentow pamieci do\nwielokrotnosci wielkosci ramki\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku moze byc wyeliminowana przez relokacje programow\n[ ] TAK\n[X] NIE","Fragmentacja wewnetrzna dysku jest wynikiem bledow programowych np. nie zwalniania pamieci\nprzed zakonczeniem programu\n[ ] TAK\n[X] NIE","Fragmentacja zewnetrzna pamieci jest wynikiem niedopasowania rozmiaru segmentow pamieci do\nwielokrotnosci wielkosci ramki\n[ ] TAK\n[X] NIE","Fragmentacja zewnetrzna pamieci moze byc wyeliminowana przez relokacje programow\n[X] TAK\n[ ] NIE","Fragmentacja zewnetrzna pamieci jest wynikiem bledow programowych np. nie zwalniania pamieci\nprzed zakonczeniem programu\n[ ] TAK\n[X] NIE","Algorytm przelaczania procesow w systemie unix jest algorytmem ze stalym priorytetem\nzewnetrznym, zadawanym komenda/funkcja nice\n[X] TAK\n[ ] NIE","Algorytm przelaczania procesow w systemie unix jest algorytmem bez wywlaszczen\n[ ] TAK\n[X] NIE","Algorytm przelaczania procesow w systemie unix jest algorytmem z wywlaszczeniem procesow\nsystemowych i uzytkowych\n[ ] TAK\n[X] NIE","Algorytm przelaczania procesow w systemie unix jest algorytmem, w ktorym wywlaszczane sa tylko\nprocesy uzytkownika\n[X] TAK\n[ ] NIE","Algorytm przelaczania procesow w systemie unix jest algortmem priorytetowym, w ktorym priorytet\njest wewnetrznie zmieniany w trakcie wykonywania procesu\n[X] TAK\n[ ] NIE","Algorytm przelaczania procesow w systemie unix jest algorytmem z wywlaszczeniem\n[X] TAK\n[ ] NIE","Algorytm przelaczania procesow w systemie unix opiera sie na priorytecie statycznym, wyliczanym w\nopraciu o wykorzystanie procesora przez proces\n[ ] TAK\n[X] NIE","Algorytm przelaczania procesow w systemie unix opiera sie na priorytecie dynamicznym, obnizanym\ndla procesow intensywnych obliczeniowo, a podwyzszanym dla procesow interakcyjnych\n[X] TAK\n[ ] NIE","Algorytm przelaczania procesow w systemie unix pozwala modyfikowac priorytet procesu przy\npomocy funkcji nice\n[X] TAK\n[ ] NIE","Algorytm karuzelowy przelaczania procesow jest algorytmem bez wywlaszczenia\n[ ] TAK\n[X] NIE","Algorytm karuzelowy przelaczania procesow jest algorytmem z wywlaszczeniem\n[X] TAK\n[ ] NIE","Algorytm karuzelowy przelaczania procesow przelacza procesy wedlug dynamicznie zmienianego\npriorytetu\n[ ] TAK\n[X] NIE","Algorytm karuzelowy przelaczania procesow jest najczesciej wykorzystywanym algorytmem w\nroznych wersjach systemu operacyjnego unix\n[ ] TAK\n[X] NIE","Algorytm karuzelowy przelaczania procesow polega na uruchamianiu procesow na staly kwant czasu i\nwymuszaniu przelaczenia kontekstu, jezeli proces nie zwolni procesora w tym czasie\n[X] TAK\n[ ] NIE","Algorytm karuzelowy przelaczania procesow jest algorytmem optymalnym, w praktyce niemozliwym\ndo zrealizowania\n[ ] TAK\n[X] NIE","Algorytmy przelaczania procesow z wywlaszczeniem moga wykorzystywac priorytety stale lub\nzmieniajace sie dynamicznie\n[X] TAK\n[ ] NIE","Algorytmy przelaczania procesow z wywlaszczeniem zwiekszaja wspolczynnik wykorzystania\nprocesora w systemach wielodostepnych\n[ ] TAK\n[X] NIE","Algorytmy przelaczania procesow z wywlaszczeniem polega na uruchamianiu procesow na staly\nkwant czasu i wymuszaniu przelaczenia kontekstu, jezeli proces nie zwolni procesora w tym czasie\n[X] TAK\n[ ] NIE","Algorytm fIFO zastepowania stron pamieci gwarantuje najmniejsza mozliwa liczbe bledow stron\n[ ] TAK\n[X] NIE","Algorytm fIFO zastepowania stron pamieci gwarantuje najkrotszy czas dostepu do pamieci\n[ ] TAK\n[X] NIE","Algorytm fIFO zastepowania stron pamieci zapewnia, ze liczba bledow stron (dla tych samych\nprocesow) nie zwiekszy sie, gdy doinstalujemy (udostepnimy) dodatkowe ramki pamieci fizycznej\n[ ] TAK\n[X] NIE","Algorytm fIFO zastepowania stron pamieci polega na usuwaniu stron, ktore najdluzej przebywaly w\npamieci fizycznej\n[X] TAK\n[ ] NIE","Algorytm fIFO zastepowania stron pamieci polega na usuwaniu stron, ktore najdawniej byly uzywane\n[ ] TAK\n[X] NIE","Algorytm lRU (najdawniej uzywana) zastepowania stron pamieci gwarantuje najmniejsza mozliwa\nliczbe bledow stron\n[ ] TAK\n[X] NIE","Algorytm lRU (najdawniej uzywana) zastepowania stron pamieci zapewnia, ze liczba bledow stron\n(dla tych samych procesow) nie zwiekszy sie, gdy doinstalujemy (udostepnimy) dodatkowe ramki\npamieci fizycznej\n[X] TAK\n[ ] NIE","Algorytm lRU (najdawniej uzywana) zastepowania stron pamieci polega na usuwaniu stron, ktore\nnajdluzej przebywaly w pamieci fizycznej\n[ ] TAK\n[X] NIE","Systemy wielodostepne wymagaja architektury wieloprocesorowej\n[ ] TAK\n[X] NIE","Systemy wielodostepne wymagaja architektury jednoprocesorowej\n[ ] TAK\n[X] NIE",
"Systemy wielodostepne pozwalaja na wykonywanie wielu zadan wspolbieznie\n[X] TAK\n[ ] NIE","Systemy wielodostepne pozwalaja na wspolbiezne przetwarzanie wielu procesow (jednego lub wielu\nuzytkownikow)\n[X] TAK\n[ ] NIE","Systemy wielodostepne zapewniaja dostep wszystkich uzytkownikow do identycznych danych\n[X] TAK\n[ ] NIE","Systemy wielodostepne pozwalaja na przesylanie sobie poczty w obrebie systemu\n[X] TAK\n[ ] NIE","Systemy wielodostepne wymuszaja prace wsadowa na komputerze\n[ ] TAK\n[X] NIE","Systemy wielodostepne wymagaja wielu terminali podlaczonych do jednego komputera\n[ ] TAK\n[X] NIE","Systemy wielodostepne dziela zadania na interakcyjne i wykonywane w tle\n[X] TAK\n[ ] NIE","Dynamiczne ladowanie programu polega na wykorzystaniu bibliotek dolaczanych w trakcie\nwykonywania programu\n[ ] TAK\n[X] NIE","Dynamiczne ladowanie programu polega na ladowaniu nakladek programu, gdy sa potrzebne\n[X] TAK\n[ ] NIE","Dynamiczne ladowanie programu mozna zrealizowac w systemie ze stronnicowaniem na zadanie\n[X] TAK\n[ ] NIE","Dynamiczne laczenie programu polega na wykorzystaniu bibliotek dolaczanych w trakcie\nwykonywania programu\n[X] TAK\n[ ] NIE","Dynamiczne laczenie programu polega na ladowaniu nakladek programu, gdy sa potrzebne\n[ ] TAK\n[X] NIE","Dynamiczne laczenie programu mozna zrealizowac w systemie bez stronnicowania na zadanie\n[X] TAK\n[ ] NIE","Kryteriami rozwiazanie problemu sekcji krytycznej jest wzajemne wylaczanie - procesy musza miec\nmozliwosc wzajemnego blokowania\n[X] TAK\n[ ] NIE","Kryteriami rozwiazanie problemu sekcji krytycznej jest postep - dostep do sekcji nie moze byc\nzablokowany, jezeli nie przebywa w niej inny\n[X] TAK\n[ ] NIE","Kryteriami rozwiazanie problemu sekcji krytycznej jesr ograniczone czekanie - kazdy proces musi\nkiedys dostac sie do sekcji\n[X] TAK\n[ ] NIE","Dolaczenia w systemie plikow (links) oznaczone sa symbolem / w sciezkach dostepu\n[ ] TAK\n[X] NIE","Dolaczenia w systemie plikow (links) pozwalaja tworzyc systemy plikow o strukturze niehierarchicznej\n[X] TAK\n[ ] NIE","Dolaczenia w systemie plikow (links) sa wynikiem bledow w programie i polegaja na polaczenie sie\nlist alokacji odpowiadajacych roznym plikom w tablicy FAT\n[ ] TAK\n[X] NIE","Dolaczenia w systemie plikow (links) sa wynikiem bledow w programie i powstaja przy wielokrotnym\notwieraniu tych samych plikow do zapisu\n[ ] TAK\n[X] NIE","Dolaczenia w systemie plikow (links) wiaza nazwy plikow z INODE\xadami w systemie unix\n[X] TAK\n[ ] NIE","Dolaczenia w systemie plikow (links) tworzone sa przy otwieraniu plikow, usuwane przy zamykaniu\n[ ] TAK\n[X] NIE","Dolaczenia w systemie plikow (links) moga byc symboliczne, gdy wskazuja sciezke dostepu do pliku\nwlasciwego, lub twarde, jezeli powstaja przez zdefiniowanie drugiej nazwy dla pliku\n[X] TAK\n[ ] NIE","Przetwarzanie potokowe w unixie realizowane jest przez przekierowanie standardowego wyjscia\nkomendy pierwszej do standardowego wejscia komendy drugiej\n[X] TAK\n[ ] NIE","Przetwarzanie potokowe w unixie w powloce sh mozna je wywolac wypisujac dwie komendy w\nnawiasach okraglych, rozdzielone przecinkami\n[X] TAK\n[ ] NIE","Przetwarzanie potokowe w unixie dostepne jest tylko w systemach wieloprocesorowych\n[ ] TAK\n[X] NIE","Proces uspiony (zablokowany) oczekuje na zwolnienie procesora przez proces aktywny\n[ ] TAK\n[X] NIE","Proces uspiony (zablokowany) realizuje operacje semaforowe\n[X] TAK\n[ ] NIE","Proces uspiony (zablokowany) zawsze usuwany jest z pamieci operacyjnej (kopiowany do obszaru\nwymiany)\n[ ] TAK\n[X] NIE","Stronicowanie na zadanie polega na wymianie stron w pamieci fizycznej, wczytywaniu stron, do\nktorych wystepuja aktualnie odwolania\n[X] TAK\n[ ] NIE","Stronicowanie na zadanie umozliwia zapisywanie do obszaru wymiany na dysku fragmentow\nkontekstow procesow, gdy brakuje pamieci fizycznej\n[X] TAK\n[ ] NIE","Mechanizm spotkaniowy to technika synchronizacji dostepu do pamieci wspoldzielonej przez procesy\n[X] TAK\n[ ] NIE","Mechanizm spotkaniowy wykorzystywany jest do przesylania danych pomiedzy procesami\n[X] TAK\n[ ] NIE","Mechanizm spotkaniowy wykorzystywany jest do negocjacji dostepu do plikow\n[ ] TAK\n[X] NIE","Warunek postepu w synchronizacji miedzy procesami to zapewnienie, ze dwa procesu nie znajda sie\nw tym samym czasie w sekcji krytycznej\n[ ] TAK\n[X] NIE","Warunek postepu w synchronizacji miedzy procesami to wymaganie, aby synchronizacja nie\npowodowala nieograniczonego w czasie zawieszenia procesu\n[X] TAK\n[ ] NIE","Warunek postepu w synchronizacji miedzy procesami zapewnia, ze proces nie jest wywlaszczany, gdy\nznajduje sie w sekcji krytycznej\n[ ] TAK\n[X] NIE","Planowanie zadan ma na celu unikanie blokad\n[ ] TAK\n[X] NIE","Planowanie zadan ma na celu synchronizowanie dostepu do zasobow\n[ ] TAK\n[X] NIE","Planowanie zadan ma na celu wybor procesu do aktywacji\n[X] TAK\n[ ] NIE","Funkcja systemowa fork w unixie (Linuxie) tworzy nowy proces, realizujacy program podany w\nargumencie do tej funkcji\n[ ] TAK\n[X] NIE","Funkcja systemowa fork w unixie (Linuxie) tworzy nowy watek, realizujacy funkcje podana w\nargumencie\n[ ] TAK\n[X] NIE","Funkcja systemowa fork w unixie (Linuxie) tworzy nowy proces, realizujacy ten sam program co\nproces-rodzic\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix generowane sa wylacznie przez sterowniki urzadzen zewntrznych\n[ ] TAK\n[X] NIE","Sygnaly w systemie unix wysylane sa do pojedynczych procesow, grup procesow, procesow\nokreslonego uzytkownika lub do wszystkich procesow\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix moga byc ignorowane przez procesy (z wyjatkiem sygnalu 9)\n[ ] TAK\n[X] NIE","Pozycje katalogowe zawieraja nazwy plikow\n[X] TAK\n[ ] NIE","Pozycje katalogowe zawieraja informacje o polozeniu pliku na dysku\n[X] TAK\n[ ] NIE","Pozycje katalogowe zawieraja sume kontrolna pliku\n[ ] TAK\n[X] NIE","Sciezka do pliku moze byc wzgledna, bezwzgledna lub symboliczna\n[ ] TAK\n[X] NIE",
"Sciezka do pliku jest sciezka wzgledna okreslajaca polozenie pliku wzgledem katalogu domowego\nuzytkownika\n[ ] TAK\n[X] NIE",
"Sciezka do pliku jest sciezka bezwzgledna okreslaca polozenie pliku wzgledem katalogu glownego\n[X] TAK\n[ ] NIE","Sekcja krytyczna to technika synchronizacji dostepu do pamieci wspoldzielonej przez procesy\n[ ] TAK\n[X] NIE","Sekcja krytyczna wykorzystywana jest do ochrony danych przed rownoczesna ich modyfikacja przez\nprocesy wspolbiezne\n[X] TAK\n[ ] NIE","Sekcja krytyczna wykorzystywana jest do negocjacji dostepu do semaforow\n[ ] TAK\n[X] NIE","Wspolbieznosc w systemach operacyjnych realizowana jest przez przelaczanie procesow, tzn.\nwstrzymywanie procesow co pewien czas i pre innych\n[X] TAK\n[ ] NIE","Wspolbieznosc w systemach operacyjnych w powloce sh mozna ja wywolac wypisujac dwie komendy\nw nawiasach okraglych, rozdzielone przecinkami\n[ ] TAK\n[X] NIE","Wspolbieznosc w systemach operacyjnych dostepna jest tylko w systemach wieloprocesorowych\n[ ] TAK\n[X] NIE","Proces gotowy oczekuje na zwolnienie procesora przez proces aktywny\n[X] TAK\n[ ] NIE","Proces gotowy realizuje operacje drugoplanowe\n[ ] TAK\n[X] NIE","Proces gotowy czasami usuwany jest z pamieci operacyjnej (kopiowany do obszaru wymiany)\n[ ] TAK\n[X] NIE","Funkcja systemowa exec w unixie (Linuxie) tworzy nowy proces, realizujacy program podany w\nargumencie do tej funkcji\n[ ] TAK\n[X] NIE","Funkcja systemowa exec w unixie (Linuxie) tworzy nowy watek, realizujacy funkcje podana w\nargumencie\n[ ] TAK\n[X] NIE","Funkcja systemowa exec w unixie (Linuxie) modyfikuje kontekst wykonywanego procesu, korzystajac\nz pliku wykonywalnego podanego w argumencie\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix generowane sa przez wykonanie operacji kill\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix moga powodowac zakonczenie procesu\n[ ] TAK\n[X] NIE","Sygnaly w systemie unix moga byc wyslane do wielu procesow rownoczesnie\n[X] TAK\n[ ] NIE","Dowiazania symboliczne sa to pliki specjalne, ktore wskazuja na inne obiekty w systemie plikow\n[X] TAK\n[ ] NIE","Dowiazania symboliczne zawieraja informacje o polozeniu pliku na dysku\n[X] TAK\n[ ] NIE","Dowiazania symboliczne w unixie musza miec rozszerzenie .lnk\n[ ] TAK\n[X] NIE","Wzorce plikow sa mechanizmem definiowania dopuszczalnej zawartosci plikow\n[ ] TAK\n[X] NIE","Wzorce plikow pozwalaja definiowac sciezki wyszukiwania komend w systemach operacyjnych\n[X] TAK\n[ ] NIE","Wzorce plikow wykorzystuja znaki ? oraz * do okreslania dowolnych znakow w nazwie pliku\n[X] TAK\n[ ] NIE","Funkcja systemowa execve w unixie(Linuxie) tworzy nowy proces, realizujacy program podany w\nargumencie do tej funkcji\n[ ] TAK\n[X] NIE","Funkcja systemowa execve w unixie(Linuxie) tworzy nowy watek, realizujacy funkcje podana w\nargumencie\n[ ] TAK\n[X] NIE","Funkcja systemowa execve w unixie(Linuxie) tworzy nowy proces, realizujacy ten sam program co\nproces-rodzic\n[ ] TAK\n[X] NIE","Pozycje katalogowe w systemie unix zawieraja nazwy plikow\n[X] TAK\n[ ] NIE","Pozycje katalogowe w systemie unix zawieraja date modyfikacji pliku\n[X] TAK\n[ ] NIE","Pozycje katalogowe w systemie unix zawieraja rozszerzenie 3 - znakowe\n[ ] TAK\n[X] NIE","Stan procesu jest pamietany w tablicy procesow\n[X] TAK\n[ ] NIE","Stan procesu jest wyznaczany przy pierwszym uruchomieniu procesu i potem sie nie zmienia\n[ ] TAK\n[X] NIE","Stan procesu jezeli jest aktywny, to proces jest wykonywany przez procesor\n[X] TAK\n[ ] NIE","Sygnaly w systemie unix generowane sa wylacznie przez sterowniki urzadzen zewnetrznych\n[ ] TAK\n[X] NIE","Sygnaly w systemie unix wysylane sa do pojedynczych procesow lub do grup procesow\n[X] TAK\n[ ] NIE","Wiekszosc sygnalow w systemie unix moze byc ignorowana przez procesy\n[X] TAK\n[ ] NIE","Kanal komunikacyjny z ograniczonym buforowaniem to technika synchronizacji dostepu do karty\nsieciowej przez procesy\n[ ] TAK\n[X] NIE","Kanal komunikacyjny z ograniczonym buforowaniem wykorzystywany jest do przesylania danych\npomiedzy procesami\n[X] TAK\n[ ] NIE","Kanal komunikacyjny z ograniczonym buforowaniem moze spowodowac uspienie procesu piszacego\ndo kanalu\n[X] TAK\n[ ] NIE","Warunek wykluczania w synchronizacji miedzy procesami to zapewnienie, ze dwa procesy nie znajda\nsie w tym samym czasie w sekcji krytycznej\n[X] TAK\n[ ] NIE","Warunek wykluczania w synchronizacji miedzy procesami to wymaganie, aby synchronizacja nie\npowodowala nieograniczonego w czasie zawieszenia procesu\n[ ] TAK\n[X] NIE","Warunek wykluczania w synchronizacji miedzy procesami zapewnia, ze proces nie jest wywlaszczany,\ngdy znajduje sie w sekcji krytycznej\n[ ] TAK\n[X] NIE","Funkcja systemowa signal w unixie (Linuxie) tworzy nowy proces\n[ ] TAK\n[X] NIE","Funkcja systemowa signal w unixie (Linuxie) wysyla komunikat do standardowego strumienia bledow\n[ ] TAK\n[X] NIE","Funkcja systemowa signal w unixie (Linuxie) wysyla sygnal do procesu lub grupy procesow\n[ ] TAK\n[X] NIE","Algorytm karuzelowy zapewnia wszystkim procesom ten sam priorytet\n[X] TAK\n[ ] NIE","Algorytm karuzelowy nie pozwala wywlaszczac procesow systemowych\n[ ] TAK\n[X] NIE","Algorytm karuzelowy jest algorytmem z priorytetami dynamicznymi\n[ ] TAK\n[X] NIE","Algorytm lRU zastepowania stron pamieci wirtualnej polega na usuwaniu najdluzej zaladowanych\nstron\n[ ] TAK\n[X] NIE","Algorytm lRU zastepowania stron pamieci wirtualnej zapewnia dobre dostosowanie do zestawu\nroboczego stron\n[X] TAK\n[ ] NIE","Algorytm lRU zastepowania stron pamieci wirtualnej zapewnia zawsze najmniejsza liczbe bledow\nstron (w porownaniu z innymi algorytmami)\n[ ] TAK\n[X] NIE","Biblioteki laczone dynamicznie (DLL) ladowane sa do pamieci tylko funkcje, do ktorych wystapi\nodwolanie\n[X] TAK\n[ ] NIE","Biblioteki laczone dynamicznie (DLL) udostepniaja wylacznie funkcje wielowejsciowe (reentrant)\n[ ] TAK\n[X] NIE","Biblioteki laczone dynamicznie (DLL) kopiowane sa w calosci do plikow wykonywalnych,\nzawierajacych programy z nich korzystajace\n[ ] TAK\n[X] NIE","Buforowanie operacji dyskowych Eliminuje fragmentacje wewnetrzna w systemie plikow\n[ ] TAK\n[X] NIE","Buforowanie operacji dyskowych umozliwia zapis danych do pliku porcjami roznej wielkosci\n[X] TAK\n[ ] NIE","Buforowanie operacji dyskowych umozliwia zrownoleglenie procesow\n[ ] TAK\n[X] NIE","Dowiazania symboliczne w linuxie zawieraja informacje o polozeniu pliku na dysku\n[ ] TAK\n[X] NIE","Dowiazania symboliczne w linuxie musza miec rozszerzenie .ink\n[ ] TAK\n[X] NIE","Dowiazania symboliczne w linuxie sa to pliki specjalne, ktore wskazuja przy pomocy sciezek na inne\nobiekty\n[X] TAK\n[ ] NIE","Dynamiczne laczenie programu zmniejsza wielkosc pliku wykonywalnego (exe)\n[X] TAK\n[ ] NIE","Dynamiczne laczenie programu wykorzystuje biblioteki statyczne\n[ ] TAK\n[X] NIE","Dynamiczne laczenie programu polega na tworzeniu polaczen dynamicznych pomiedzy procesami\n[ ] TAK\n[X] NIE","Dynamiczne ladowanie programu polega na ladowaniu nakladek programu, gdy sa potrzebne\n[X] TAK\n[ ] NIE","Dynamiczne ladowanie programu polega na wykorzystaniu bibliotek dolaczanych w trakcie\nwykonywania programu\n[ ] TAK\n[X] NIE","Dynamiczne ladowanie programu zmniejsza czas od wydania komendy do uruchomienia programu\n[ ] TAK\n[X] NIE","Funkcja systemowa signal tworzy nowy proces\n[ ] TAK\n[X] NIE","Funkcja systemowa signal wysyla sygnal do procesu lub grupy procesow\n[ ] TAK\n[X] NIE","Funkcja systemowa signal wysyla komunikat do standardowego strumienia bledow\n[X] TAK\n[ ] NIE","Funkcja systemowa fork w unicie (Linuxie) tworzy nowy proces, realizujacy ten sam program co\nproces-rodzic\n[X] TAK\n[ ] NIE","Funkcja systemowa fork w unicie (Linuxie) tworzy nowy watek, realizujacy funkcje podana w\nargumencie\n[ ] TAK\n[X] NIE","Funkcja systemowa fork w unicie (Linuxie) tworzy nowy proces, realizujacy program podany w\nargumencie do tej funkcji\n[ ] TAK\n[X] NIE","Funkcja systemowa execve w unixie (Linuxie) laduje nowy program w miejsce obrazu pamieci\nprocesu, ktory wywolal te funkcje\n[X] TAK\n[ ] NIE","Funkcja systemowa execve w unixie (Linuxie) tworzy nowy proces, realizujacy program podany w\nargumencie do tej funkcji\n[ ] TAK\n[X] NIE","Funkcja systemowa execve w unixie (Linuxie) tworzy nowy watek, realizujacy funkcje podana w\nargumencie\n[ ] TAK\n[X] NIE","Kanal komunikacyjny z zerowym buforowaniem umozliwia buforowanie operacji dyskowych\n[ ] TAK\n[X] NIE","Kanal komunikacyjny z zerowym buforowaniem to kanal, w ktorym aktualnie nie ma zadnych\nkomunikatow\n[X] TAK\n[ ] NIE","Kanal komunikacyjny z zerowym buforowaniem moze powodowac uspienie procesu czytajacego z\nkanalu\n[ ] TAK\n[X] NIE","Kontekst procesu jest to obraz pamieci, rejestrow i zmiennych systemowych procesu w pewnej chwili\n[ ] TAK\n[X] NIE","Kontekst procesu obejmuje informacje konieczne do zablokowania procesu\n[ ] TAK\n[X] NIE","Kontekst procesu opisuje stan wszystkich zasobow, z ktorych moze proces korzystac\n[X] TAK\n[ ] NIE","Kanal komunikacyjny z nieograniczonym buforowaniem moze powodowac uspienie procesu\npiszacego do kanalu\n[ ] TAK\n[X] NIE","Kanal komunikacyjny z nieograniczonym buforowaniem moze powodowac uspienie procesu\nczytajacego z kanalu\n[ ] TAK\n[X] NIE","Kanal komunikacyjny z nieograniczonym buforowaniem umozliwia buforowanie operacji dyskowych\n[X] TAK\n[ ] NIE","Ogole semafory dijkstry przyjmuja tylko wartosci 0 lub 1\n[X] TAK\n[ ] NIE","Ogole semafory dijkstry moga blokowac proces przy wykonaniu operacji V\n[ ] TAK\n[X] NIE","Ogole semafory dijkstry moga blokowac proces przy wykonywaniu operacji p\n[X] TAK\n[ ] NIE","Ochrona pamieci w systemach operacyjnych okresla prawa dostepu procesow do pamieci dyskowej\n[ ] TAK\n[X] NIE","Ochrona pamieci w systemach operacyjnych zapewnia, ze procesy nie zostana zmodyfikowane w\ntrakcie kopiowania do obszaru wymiany (swapping)\n[ ] TAK\n[X] NIE","Ochrona pamieci w systemach operacyjnych uniemozliwia dostep procesu do niezaalokowanej\npamieci\n[X] TAK\n[ ] NIE","Przetwarzanie posrednie to technika przydzielania dodatkowych buforow procesom\nuprzywilejowanym\n[ ] TAK\n[X] NIE","Przetwarzanie posrednie eliminuje fragmentacje zewnetrzna dysku przez przesuwanie plikow w tle\n[ ] TAK\n[X] NIE","Przetwarzanie posrednie polega na kopiowaniu danych miedzy dyskiem a wolnymi urzadzeniami\nzewnetrznymi w celu poprawy wykorzystania procesora\n[X] TAK\n[ ] NIE","Przetwarzanie potokowe dostepne jest tylko w systemach wieloprocesorowych\n[ ] TAK\n[X] NIE","Przetwarzanie potokowe w powloce sh mozna je wywolac wypisujac dwie komendy w nawiasach\nokraglych rozdzielone przecinkami\n[ ] TAK\n[X] NIE","Przetwarzanie potokowe realizowane jest przez przekierowanie standardowego wyjscia komendy\npierwszej do standardowego wejscia komendy drugiej\n[X] TAK\n[ ] NIE","Przydzial indeksowy miejsca na dysku charakteryzuje sie fragmentacja zewnetrzna przestrzeni dysku\n[ ] TAK\n[X] NIE","Przydzial indeksowy miejsca na dysku wymaga zapisu tablicy indeksowej na dysku\n[X] TAK\n[ ] NIE","Przydzial indeksowy miejsca na dysku opisuje polozenie pliku jako ciag segmentow roznej wielkosci\n[ ] TAK\n[X] NIE","Proces moze przejsc do stanu zablokowania bezposrednio ze stanu aktywnosci\n[X] TAK\n[ ] NIE","Proces moze przejsc do stanu zablokowania w wyniku wykonania funkcji exit (w linuxie)\n[ ] TAK\n[X] NIE","Proces moze przejsc do stanu zablokowania po wyczerpaniu kwantu czasu aktywnosci\n[ ] TAK\n[X] NIE","Proces uspiony (zablokowany) zawsze usuwany jest z pamieci operacyjnej (kopiowany do obszaru\nwymiany)\n[ ] TAK\n[X] NIE","Proces uspiony (zablokowany) oczekuje az inny proces go zbudzi\n[X] TAK\n[ ] NIE","Proces uspiony (zablokowany) oczekuje na zwolnienie procesora przez procesor aktywny\n[ ] TAK\n[X] NIE","Powloka systemu operacyjnego okresla zestaw dostepnych jezykow programowania\n[ ] TAK\n[X] NIE",
"Powloka systemu operacyjnego okresla dostepny zestaw komend wewnetrznych\n[ ] TAK\n[X] NIE","Powloka systemu operacyjnego pozwala definiowac zmienne srodowiskowe, przekazywane do\nuruchamianych programow\n[ ] TAK\n[X] NIE","Pozycje katalogowe w systemie FAT pozwalaja definiowac nazwy plikow dowolnej wielkosci\n[ ] TAK\n[X] NIE","Pozycje katalogowe w systemie FAT zawieraja informacje o polozeniu pliku na dysku\n[X] TAK\n[ ] NIE","Pozycje katalogowe w systemie FAT zawieraja sume kontrolna pliku\n[ ] TAK\n[X] NIE","Przydzial ciagly miejsca na dysku wymaga zapisu tablicy indeksowanej na dysku\n[ ] TAK\n[X] NIE","Przydzial ciagly miejsca na dysku jest algorytmem optymalnym, nie dajacym sie zaimplementowac w\npraktyce\n[ ] TAK\n[X] NIE","Przydzial ciagly miejsca na dysku charakteryzuje sie fragmentacja zewnetrzna przestrzeni dysku\n[X] TAK\n[ ] NIE","Planowanie zadan (scheduling) ma na celu synchronizowanie dostepu do zasobow\n[ ] TAK\n[X] NIE","Planowanie zadan (scheduling) ma na celu wybor procesu do aktywacji\n[X] TAK\n[ ] NIE","Planowanie zadan (scheduling) ma na celu unikanie blokad\n[ ] TAK\n[X] NIE","Planowanie srednioterminowe okresla kolejnosc kopiowania procesow do pamieci z obszaru\nwymiany\n[X] TAK\n[ ] NIE","Planowanie srednioterminowe wybiera proces do uruchomienia sposrod procesow gotowych\n[X] TAK\n[ ] NIE","Planowanie srednioterminowe okresla procesy, ktore nalezy odblokowac\n[ ] TAK\n[X] NIE","Sekcja krytyczna to technika synchronizacji dostepu do pamieci wspoldzielonej przez procesor\n[ ] TAK\n[X] NIE","Sekcja krytyczna wykorzystywana jest do negocjacji dostepu do semaforow\n[ ] TAK\n[X] NIE","Sekcja krytyczna wykorzystywana jest od ochrony danych przed rownoczesna ich modyfikacja przez\nprocesy wspolbiezne\n[X] TAK\n[ ] NIE","Sygnaly w systemie linux generowane sa wylacznie przez sterowniki urzadzen zewnetrznych\n[ ] TAK\n[X] NIE","Sygnaly w systemie linux nie moga byc ignorowane przez procesy\n[ ] TAK\n[X] NIE","Sygnaly w systemie linux wysylane sa do pojedynczych procesow, grup procesow, procesow\nokreslonego uzytkownika lub do wszystkich procesow\n[X] TAK\n[ ] NIE","Swobodny (zrandomizowany), dostep do pliku polega na wspoldzieleniu otwartych plikow przez\nwiele procesow\n[ ] TAK\n[X] NIE","Swobodny (zrandomizowany), dostep do pliku szereguje dostep wielu procesow do pliku\n[ ] TAK\n[X] NIE","Swobodny (zrandomizowany), dostep do pliku pozwala na wystepowanie plikow nieciaglych, z\nniezaalokowanymi dziurami\n[X] TAK\n[ ] NIE","Stan procesu przechowywany jest w jadrze systemu operacyjnego w obszarze uarea\n[ ] TAK\n[X] NIE","Stan procesu Identyfikuje procesy, ktore nie wymagaja dostepu do urzadzen zewnetrznych\n[ ] TAK\n[X] NIE","Stan procesu okresla, czy procesor jest przydzielony do procesu\n[X] TAK\n[ ] NIE","Stronicowanie na zadanie wymaga tworzenia obrazu pamieci w obszarze wymiany\n[X] TAK\n[ ] NIE","Stronicowanie na zadanie wykorzystuje segmentacje pamieci\n[ ] TAK\n[X] NIE","Stronicowanie na zadanie wlaczane jest na zadanie procesu (przez wywolanie funkcji swapon)\n[ ] TAK\n[X] NIE","Sciezka do pliku to sciezka bezwzgledna okreslajaca polozenie pliku wzgledem katalogu glownego\n[X] TAK\n[ ] NIE","Sciezka do pliku moze byc wzgledna, bezwzgledna lub symboliczna\n[ ] TAK\n[X] NIE","Sciezka do pliku to sciezka symboliczna okreslajaca polozenie pliku wzgledem katalogu domowego\nuzytkownika\n[ ] TAK\n[X] NIE","Warunek postepu w synchronizacji miedzy procesami to zapewnienie, ze dwa procesy nie znajda sie\nw tym samym czasie w sekcji krytycznej\n[ ] TAK\n[X] NIE","Warunek postepu w synchronizacji miedzy procesami to wymaganie, aby proces nie byl usypiany przy\nwejsciu do sekcji krytycznej, gdy nie ma w niej innych procesow\n[X] TAK\n[ ] NIE","Warunek postepu w synchronizacji miedzy procesami zapewnia, ze proces nie jest wywlaszczany, gdy\nznajduje sie w sekcji krytycznej\n[ ] TAK\n[X] NIE","Warunek wykluczania w synchronizacji miedzy procesami zapewnia, ze proces nie jest wywlaszczany,\ngdy znajduje sie w sekcji krytycznej\n[ ] TAK\n[X] NIE","Warunek wykluczania w synchronizacji miedzy procesami to zapewnienie, ze dwa procesy nie znajda\nsie w tym samym czasie w sekcji krytycznej\n[X] TAK\n[ ] NIE","Warunek wykluczania w synchronizacji miedzy procesami wymaga, aby proces mial dostep do sekcji\nkrytycznej, gdy nie przebywa w niej inny\n[ ] TAK\n[ ] NIE"
        // KOLEJNE

]


console.log("dupa")
var fuse = new Fuse(questions, {
includeScore: true,
findAllMatches: true,
threshold: 0.7,
ignoreLocation: true,
useExtendedSearch: false,
});
console.log("xdws")

function handleQuestion(el) {
function questionText() {
    return document.querySelector('#question').value;
}



var question_text = questionText();

console.log('question text:', question_text);


var results_from_question = fuse.search(question_text);

console.log('fuzzy search results from the question:', results_from_question);

if((!results_from_question || results_from_question.length == 0)) {
console.log('Nothing matched for element ', el);
return '';
}

var refIndices1 = results_from_question.map(x => x.refIndex);

if(results_from_question.length > 10)
results_from_question.length = 10;


var results = results_from_question;

results.sort((x,y) => x.score - y.score);

if(results.length > 10)
results.length = 10;

function processText(text) {
return text
    .replace(/</g, '<')
    .replace(/>/g, '>')
    .replace(/\n/g, '<br />')
    .replace(/_(.)/g, '<sub>$1</sub>')
    .replace(/\^(.)/g, '<sup>$1</sup>')
}

var text = results
.map(result => "" + Math.round((1-result.score)*10000)/100 + "%: <br />" + processText(result.item))
.join('<br /><br />');

return text
}

var found = [...document.querySelectorAll('#question')].map(questionElement => handleQuestion(questionElement))

var text;
if(found.length == 0 || found.join('') == '') {
text = "<b>Nie znaleziono pyta :/</b>"
} else if(found.length == 1) {
text = found[0]
} else {
text =
"<b>Znaleziono " + found.length + (found.length < 5 ? " pytania." : " pyta.") + "</b>"
+ found
    .map((v, i) => "<br /><br /><b>====== PYTANIE " + (i + 1) + " ======</b><br /><br />" + v)
    .join('')

}

var d=document.createElement('div')
d.style='border:1px solid black;padding: 10px; margin: 10px'
d.class='mb-3'
d.innerHTML = text;
document.querySelector('#answer-list').appendChild(d)
}

const clearButton = document.querySelector("#clear");

clearButton.addEventListener("click", clearAnswers);
function clearAnswers(){
    document.querySelector('#answer-list').innerHTML = ''
}



</script>

</html>
